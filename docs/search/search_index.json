{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Benvinguts a la Web de Posada en Producci\u00f3 Segura Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna","title":"Home"},{"location":"#benvinguts-a-la-web-de-posada-en-produccio-segura","text":"Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna","title":"Benvinguts a la Web de Posada en Producci\u00f3 Segura"},{"location":"about/","text":"Sobre la web de PPS Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna Autor: Ferran Cunyat Pellicer - Departament d'Inform\u00e0tica","title":"About"},{"location":"about/#sobre-la-web-de-pps","text":"Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna Autor: Ferran Cunyat Pellicer - Departament d'Inform\u00e0tica","title":"Sobre la web de PPS"},{"location":"Unitats/Unitat%201/CD-CI/","text":"Metodologia CI/CD (integraci\u00f3 i desplegaments continus) \"La integraci\u00f3 cont\u00ednua \u00e9s una pr\u00e0ctica de desenvolupament de programari on els membres d'un equip integren el seu treball amb freq\u00fc\u00e8ncia, normalment cada persona integra almenys di\u00e0riament, donant lloc a m\u00faltiples integracions per dia. Cada integraci\u00f3 es verifica mitjan\u00e7ant una compilaci\u00f3 automatitzada (inclosa la prova) per detectar errors d'integraci\u00f3 el m\u00e9s r\u00e0pidament possible\". La programaci\u00f3 \u00e9s iterativa, \u00e9s a dir, es va repetint continuament. El codi font s'allotja a un repositori que \u00e9s compartit per tots els membres de l'equip. Si voleu treballar en aquest producte, n'heu d'obtenir una c\u00f2pia. Fareu canvis, els provareu i els tornareu a integrar al repositori principal. No fa gaire, aquestes integracions eren grans i amb setmanes (o mesos) de difer\u00e8ncia, causant mals de cap, perdre temps i perdre diners. Armats amb experi\u00e8ncia, els desenvolupadors van comen\u00e7ar a fer canvis menors i a integrar-los amb m\u00e9s freq\u00fc\u00e8ncia. Aix\u00f2 redueix les possibilitats d'introduir conflictes que cal resoldre m\u00e9s tard. Despr\u00e9s de cada integraci\u00f3, heu de crear el codi font. Construir significa transformar el vostre codi d'alt nivell en un format que el vostre ordinador sap executar. Finalment, el resultat es prova sistem\u00e0ticament per assegurar-vos que als vostres canvis no han introdu\u00eft errors. Com sona aix\u00f2? A nivell d'equip, permet una millor cultura d'enginyeria, on proporcioneu valor aviat i sovint. Es fomenta la col\u00b7laboraci\u00f3 i es detecten errors molt abans. La integraci\u00f3 cont\u00ednua permetr\u00e0: Fer que tu i el teu equip siguen m\u00e9s r\u00e0pids Donar-vos la confian\u00e7a que esteu creant programari estable amb menys errors, i que el llan\u00e7ament a producci\u00f3 funciona Assegurar-vos que el vostre producte funcione en altres m\u00e0quines, no nom\u00e9s en el vostre ordinador port\u00e0til Eliminar moltes despeses generals tedioses i permet centrar-vos en all\u00f2 que importa Reduir el temps dedicat a resoldre conflictes (quan diferents persones modifiquen el mateix codi) Conceptes b\u00e0sics Hi ha diverses idees i pr\u00e0ctiques clau que cal entendre per treballar de manera efica\u00e7 amb una integraci\u00f3 cont\u00ednua. A m\u00e9s, pot haver-hi algunes paraules i frases que no coneixeu, per\u00f2 que s'utilitzen sovint quan parleu de CI. Aquest cap\u00edtol us introduir\u00e0 en aquests conceptes i l'argot que els acompanya. Repositori d'origen \u00fanic Si col\u00b7laboreu amb altres persones en una \u00fanica base de codi, \u00e9s habitual tenir un repositori compartit de codi font. Cada desenvolupador que treballa en el projecte crea una c\u00f2pia local i fa canvis. Un cop estan satisfets amb els canvis, els fusionen de nou al repositori central. S'ha convertit en un est\u00e0ndard utilitzar sistemes de control de versions (VCS) com Git per gestionar aquest flux de treball. Els equips solen utilitzar un servei extern per allotjar el seu codi font i gestionar totes les parts m\u00f2bils. Els m\u00e9s populars s\u00f3n GitHub, BitBucket i GitLab. Git us permet crear diverses branques d'un dip\u00f2sit. Cada branca \u00e9s una c\u00f2pia independent del codi font i es pot modificar sense afectar altres branques. Aquesta \u00e9s una caracter\u00edstica essencial, i la majoria dels equips tenen una branca principal (sovint anomenada branca mestra) que representa l'estat actual del projecte. Si voleu afegir o modificar codi, haur\u00edeu de crear una c\u00f2pia de la branca principal i treballar a la vostra nova branca de desenvolupament. Un cop h\u00e0giu acabat, torneu a combinar aquests canvis a la branca mestra. El control de versions inclou m\u00e9s que codi. La documentaci\u00f3 i els scripts de prova s'emmagatzemen normalment juntament amb el codi font. Alguns programes busquen fitxers externs utilitzats per configurar els seus par\u00e0metres i par\u00e0metres inicials. Altres aplicacions necessiten un esquema de base de dades. Tots aquests fitxers haurien d'anar al vostre repositori. Automatitzaci\u00f3 de la construcci\u00f3 Com s'ha esmentat anteriorment, construir el vostre codi significa agafar el codi font en brut, i tot el necessari per a la seva execuci\u00f3, i traduir-lo a un format que els ordinadors puguin executar directament. Python \u00e9s un llenguatge interpretat, de manera que la seva \"construcci\u00f3\" gira principalment al voltant de l'execuci\u00f3 de proves en lloc de la compilaci\u00f3. Executar aquests passos manualment despr\u00e9s de cada petit canvi \u00e9s tedi\u00f3s i requereix un temps i una atenci\u00f3 valuosos de la resoluci\u00f3 de problemes real que esteu intentant fer. Una gran part de la integraci\u00f3 cont\u00ednua \u00e9s automatitzar aquest proc\u00e9s. Qu\u00e8 significa aix\u00f2 per a Python? Penseu en un fragment de codi m\u00e9s complicat que h\u00e0giu escrit. Si heu utilitzat una biblioteca, paquet o framework que no ve amb la biblioteca est\u00e0ndard de Python (penseu qualsevol cosa que necessiteu instal\u00b7lar amb pip), Python ha de saber-ho, de manera que el programa s\u00e0piga on buscar quan trobe. ordres que no reconeix. Emmagatzemeu una llista d'aquests paquets a requirements.txt o un fitxer Pipfile. Aquestes s\u00f3n les depend\u00e8ncies del vostre codi i s\u00f3n necess\u00e0ries per a una construcci\u00f3 exitosa. Sovint escoltar\u00e0s la frase \"trencant la construcci\u00f3\". Quan trenqueu la compilaci\u00f3, vol dir que heu introdu\u00eft un canvi que va fer que el producte final no es puga utilitzar. No et preocupes. Li passa a tothom, fins i tot als desenvolupadors s\u00e8niors. Voleu evitar-ho principalment perqu\u00e8 impedir\u00e0 que tots els altres treballen. L'objectiu de CI \u00e9s que tothom treballe en una base estable coneguda. Si clonen un repositori que est\u00e0 trencant la compilaci\u00f3, treballaran amb una versi\u00f3 trencada del codi i no podran introduir ni provar els seus canvis. Quan trenqueu la construcci\u00f3, la m\u00e0xima prioritat \u00e9s arreglar-la perqu\u00e8 tothom puga reprendre la feina. Quan la compilaci\u00f3/construcci\u00f3 del software est\u00e0 automatitzada, podeu integrar canvis amb freq\u00fc\u00e8ncia, normalment diverses vegades al dia. Permet que les persones tinguen acc\u00e9s r\u00e0pidament als canvis i noten si hi ha un conflicte entre dos desenvolupadors. Si hi ha molts xicotets canvis en lloc d'unes quantes actualitzacions massives, \u00e9s molt m\u00e9s f\u00e0cil localitzar on es va originar l'error. Tamb\u00e9 us animar\u00e0 a dividir el vostre treball en trossos m\u00e9s xicotets, cosa que \u00e9s m\u00e9s f\u00e0cil de rastrejar i provar. Proves automatitzades Com que tothom fa canvis diverses vegades al dia, \u00e9s important saber que el vostre canvi no ha trencat res m\u00e9s al codi ni ha introdu\u00eft errors. En moltes empreses, les proves s\u00f3n ara responsabilitat de tots els desenvolupadors. Si escriviu codi, haur\u00edeu d'escriure proves. Com a m\u00ednim, haur\u00edeu de cobrir totes les funcions noves amb una prova d'unitat. L'execuci\u00f3 de proves autom\u00e0ticament, amb cada canvi, \u00e9s una bona manera de detectar errors. Una prova que falla autom\u00e0ticament fa que la compilaci\u00f3 falle. Cridar\u00e0 la vostra atenci\u00f3 sobre els problemes revelats per les proves, i la compilaci\u00f3 fallida us far\u00e0 corregir l'error que heu introdu\u00eft. Les proves no garanteixen que el vostre codi estiga lliure d'errors, per\u00f2 protegeix de molts canvis descuidats. Automatitzar l'execuci\u00f3 de proves us proporciona m\u00e9s tranquil\u00b7litat perqu\u00e8 sabeu que el servidor provar\u00e0 el vostre codi cada vegada que modifiqueu el codi contra el repositori central, fins i tot si us oblideu de fer-ho localment. \u00das d'un servei d'integraci\u00f3 cont\u00ednua externa Si alguna cosa funciona al vostre ordinador, funcionar\u00e0 a tots els ordinadors? Probablement no. \u00c9s una excusa clix\u00e9 (el t\u00edpic, \"al meu ordinador va\"). Fer que el codi funcione localment no \u00e9s el final de la vostra responsabilitat. Per fer front a aquest problema, la majoria de les empreses utilitzen un servei extern per gestionar la integraci\u00f3, de la mateixa manera que s'utilitza GitHub per allotjar el vostre repositori de codi font. Els serveis externs tenen servidors on creen codi i executen proves. Actuen com a monitors del vostre repositoris i impedeixen que ning\u00fa es fusione amb la branca mestra si els seus canvis trenquen la compilaci\u00f3. Hi ha molts serveis d'aquest tipus, amb diferents caracter\u00edstiques i preus. La majoria tenen un nivell gratu\u00eft perqu\u00e8 pugueu experimentar amb un dels vostres repositoris. Utilitzareu un servei anomenat en els exercis. Proves en un entorn preparat Un entorn de producci\u00f3 \u00e9s on finalment s'executar\u00e0 el vostre programari. Fins i tot despr\u00e9s de crear i provar la vostra aplicaci\u00f3 amb \u00e8xit, no podeu estar segur que el vostre codi funcione a l'ordinador de destinaci\u00f3. \u00c9s per aix\u00f2 que els equips despleguen el producte final en un entorn que imite l'entorn de producci\u00f3. Una vegada esteu segur que tot funciona, l'aplicaci\u00f3 es desplega a l'entorn de producci\u00f3. Sentir\u00e0s que la gent parla d'aquest clon de l'entorn de producci\u00f3 utilitzant termes com ara entorn de desenvolupament o entorn de prova. \u00c9s habitual utilitzar abreviatures com DEV per a l'entorn de desenvolupament i PROD per a l'entorn de producci\u00f3. L'entorn de desenvolupament ha de reproduir les condicions de producci\u00f3 el m\u00e0xim possible. Aquesta configuraci\u00f3 de vegades s'anomena paritat DEV/PROD. Mantingueu l'entorn de l'ordinador local el m\u00e9s semblant possible als entorns DEV i PROD per minimitzar les anomalies en desplegar aplicacions. Estos conceptes que acabem de veure \u00e9s el que s'anomena CD (continuous deployment). CI amb CircleCI i GitHub CircleCI \u00e9s un servei per a automatitzar integracions que es pot connectar a GitHub. Necessita saber com executar la vostra contrucci\u00f3 (build) i espera que aquesta informaci\u00f3 es proporcione en un format determinat. Requereix una carpeta .circleci dins del vostre repositori i un fitxer de configuraci\u00f3 dins. El fitxer de configuraci\u00f3 cont\u00e9 instruccions per a tots els passos que el servidor de construcci\u00f3 ha d'executar. CircleCI espera que aquest fitxer es diga config.yml . Un fitxer .yml utilitza un llenguatge de serialitzaci\u00f3 de dades, YAML, i t\u00e9 la seva pr\u00f2pia especificaci\u00f3. L'objectiu de YAML \u00e9s ser llegible per l'home i funcionar b\u00e9 amb llenguatges de programaci\u00f3 moderns per a les tasques quotidianes comunes. En un fitxer YAML, hi ha tres maneres b\u00e0siques de representar dades: Mapes (parells clau-valor) Seq\u00fc\u00e8ncies (llistes) Escalars (cadenes o n\u00fameros) \u00c9s molt senzill de llegir: - El sagnat es pot utilitzar per a l'estructura. - Els dos punts separen els parells clau-valor. - Els guions s'utilitzen per crear llistes. Este seria un exemple d'aquest arxiu d'integraci\u00f3: # Python CircleCI 2.0 configuration file version: 2 jobs: build: docker: - image: circleci/python:3.7 working_directory: ~/repo steps: # Step 1: obtain repo from GitHub - checkout # Step 2: create virtual env and install dependencies - run: name: install dependencies command: | python3 -m venv venv . venv/bin/activate pip install -r requirements.txt # Step 3: run linter and tests - run: name: run tests command: | . venv/bin/activate flake8 --exclude=venv* --statistics pytest -v --cov=calculator Repassem alguns conceptes: Recordeu el problema que tenen els programadors quan alguna cosa funciona al seu ordinador port\u00e0til per\u00f2, funcionar\u00e0 a qualsevol lloc? Abans, els desenvolupadors solien crear un programa que a\u00eflla una part dels recursos f\u00edsics de l'ordinador (mem\u00f2ria, disc dur, etc.) i els converteix en una m\u00e0quina virtual. Una m\u00e0quina virtual pret\u00e9n ser tot un ordinador per si mateix. Fins i tot tindr\u00e0 el seu propi sistema operatiu. En aquest sistema operatiu, desplegueu la vostra aplicaci\u00f3 o instal\u00b7leu la vostra biblioteca i la proveu. Les m\u00e0quines virtuals ocupen molts recursos, cosa que va provocar la invenci\u00f3 dels contenidors. La idea \u00e9s an\u00e0loga als contenidors d'enviament. Abans que s'inventessin els contenidors d'enviament, els fabricants havien d'enviar mercaderies en una gran varietat de mides, embalatges i modes (camions, trens, vaixells). Mitjan\u00e7ant l'estandarditzaci\u00f3 del contenidor d'enviament, aquestes mercaderies es podrien transferir entre diferents m\u00e8todes d'enviament sense cap modificaci\u00f3. La mateixa idea s'aplica als contenidors de programari. Els contenidors s\u00f3n una unitat lleugera de codi i les seves depend\u00e8ncies en temps d'execuci\u00f3, empaquetats de manera estandarditzada, de manera que es poden connectar i executar r\u00e0pidament al sistema operatiu Linux. No cal que creeu un sistema operatiu virtual complet, com ho far\u00edeu amb una m\u00e0quina virtual. Els contenidors nom\u00e9s reprodueixen parts del sistema operatiu que necessiten per funcionar. Aix\u00f2 redueix la seva mida i els d\u00f3na un gran augment de rendiment. Docker \u00e9s actualment la plataforma de contenidors l\u00edder i fins i tot \u00e9s capa\u00e7 d'executar contenidors Linux a Windows i macOS. Per crear un contenidor Docker, necessiteu una imatge de Docker. Les imatges proporcionen pl\u00e0nols per als contenidors de la mateixa manera que les classes proporcionen pl\u00e0nols per als objectes. Reprendrem el tema de Docker m\u00e9s endavant al llarg del nostre curs. CircleCI mant\u00e9 imatges de Docker preconstru\u00efdes per a diversos llenguatges de programaci\u00f3. Al fitxer de configuraci\u00f3 anterior, heu especificat una imatge de Linux que ja t\u00e9 Python instal\u00b7lat. Aquesta imatge crear\u00e0 un contenidor dins el qual es produir\u00e0 la construcci\u00f3 del programari. Configuraci\u00f3 de l'arxiu config.yml Vegem cada l\u00ednia del fitxer de configuraci\u00f3: version : cada config.yml comen\u00e7a amb el n\u00famero de versi\u00f3 de CircleCI, que s'utilitza per emetre advert\u00e8ncies sobre canvis. jobs : els treballs s\u00f3n els passos individuals que s'han de donar per a la construcci\u00f3 de l'aplicaci\u00f3. El build pot estar compost d'un sol job . build : Com s'ha dit abans, build \u00e9s el nom de la construcci\u00f3. docker : els passos d'un treball es produeixen en un entorn anomenat executor. L'executor com\u00fa de CircleCI \u00e9s un contenidor Docker. \u00c9s un entorn d'execuci\u00f3 allotjat al n\u00favol, per\u00f2 existeixen altres opcions, com ara un entorn macOS. imatge : una imatge Docker \u00e9s un fitxer utilitzat per crear un contenidor Docker en execuci\u00f3. Estem utilitzant una imatge que t\u00e9 Python 3.7 preinstal\u00b7lat. working_directory : el vostre repositori s'ha de consultar en algun lloc del servidor de compilaci\u00f3. El directori de treball representa la ruta del fitxer on s'emmagatzemar\u00e0 el repositori. steps : aquesta clau marca l'inici d'una llista de passos que ha de realitzar el servidor de compilaci\u00f3. checkout : el primer pas que ha de fer el servidor \u00e9s obtindre el codi font i portar-lo al directori de treball. Aix\u00f2 es realitza mitjan\u00e7ant un pas especial anomenat checkout . run : l'execuci\u00f3 de programes o ordres de l\u00ednia d'ordres es fa dins de la clau command . Les ordres s'executaran dins la shell del contenidor. name : la interf\u00edcie d'usuari de CircleCI us mostra cada pas de construcci\u00f3 en forma de secci\u00f3 ampliable. El t\u00edtol de la secci\u00f3 es pren del valor associat a la clau name . command : aquesta clau representa l'ordre que s'executa mitjan\u00e7ant l'int\u00e8rpret d'ordres. El s\u00edmbol | \u00e9s el car\u00e0cter que separa cadascuna de les ordres, exactament com si executarem un script de shell/bash. Per a saber m\u00e9s, consulta la seg\u00fcent guia de refer\u00e8ncia de configuraci\u00f3 de CircleCI . Workflow El nostre workflow \u00e9s molt senzill i consta de 3 passos: Consulta del repositori Instal\u00b7laci\u00f3 de les depend\u00e8ncies en un entorn virtual Execuci\u00f3 del linter i proves dins de l'entorn virtual Ara tenim tot el que necessitem per iniciar el nostre pipeline . Inicieu sessi\u00f3 al vostre compte de CircleCI i feu clic a Afegeix projectes. Localitzeu el vostre repositori i feu clic a Configura el projecte. Seleccioneu Python com a llenguatge. Com que ja tenim un config.yml, podem saltar els passos seg\u00fcents i fer clic a Comen\u00e7a a crear. CircleCI us portar\u00e0 al tauler d'execuci\u00f3 de la vostra feina. Si heu seguit tots els passos correctament, haur\u00edeu de veure que la vostra feina ha passat els tests. El repositori hauria de contindre ara els vostres canvis. Execrici 1 Configura el codi de calculadora per fer una integraci\u00f3 automatitzada. Fem canvis al nostre codi i els integrem Hi haur\u00e0 dos tipus de canvis principalment: Afegir nova funcionalitat. Aplicarem TDD a les noves funsions i afegirem el codi validat. Refactoritzar. Comprovarem que les modificacions superen els nostres testos. Exercici 2 Refactoritza la funci\u00f3 factorial, implementant-la de forma recursiva i afegix la nova versi\u00f3 al codi. Exercici 3 Afegeix una nova funci\u00f3 de c\u00e0lcul de pot\u00e8ncies a la calculadora. Fes la seua integraci\u00f3.","title":"CD/CI"},{"location":"Unitats/Unitat%201/CD-CI/#metodologia-cicd-integracio-i-desplegaments-continus","text":"\"La integraci\u00f3 cont\u00ednua \u00e9s una pr\u00e0ctica de desenvolupament de programari on els membres d'un equip integren el seu treball amb freq\u00fc\u00e8ncia, normalment cada persona integra almenys di\u00e0riament, donant lloc a m\u00faltiples integracions per dia. Cada integraci\u00f3 es verifica mitjan\u00e7ant una compilaci\u00f3 automatitzada (inclosa la prova) per detectar errors d'integraci\u00f3 el m\u00e9s r\u00e0pidament possible\". La programaci\u00f3 \u00e9s iterativa, \u00e9s a dir, es va repetint continuament. El codi font s'allotja a un repositori que \u00e9s compartit per tots els membres de l'equip. Si voleu treballar en aquest producte, n'heu d'obtenir una c\u00f2pia. Fareu canvis, els provareu i els tornareu a integrar al repositori principal. No fa gaire, aquestes integracions eren grans i amb setmanes (o mesos) de difer\u00e8ncia, causant mals de cap, perdre temps i perdre diners. Armats amb experi\u00e8ncia, els desenvolupadors van comen\u00e7ar a fer canvis menors i a integrar-los amb m\u00e9s freq\u00fc\u00e8ncia. Aix\u00f2 redueix les possibilitats d'introduir conflictes que cal resoldre m\u00e9s tard. Despr\u00e9s de cada integraci\u00f3, heu de crear el codi font. Construir significa transformar el vostre codi d'alt nivell en un format que el vostre ordinador sap executar. Finalment, el resultat es prova sistem\u00e0ticament per assegurar-vos que als vostres canvis no han introdu\u00eft errors.","title":"Metodologia CI/CD (integraci\u00f3 i desplegaments continus)"},{"location":"Unitats/Unitat%201/CD-CI/#com-sona-aixo","text":"A nivell d'equip, permet una millor cultura d'enginyeria, on proporcioneu valor aviat i sovint. Es fomenta la col\u00b7laboraci\u00f3 i es detecten errors molt abans. La integraci\u00f3 cont\u00ednua permetr\u00e0: Fer que tu i el teu equip siguen m\u00e9s r\u00e0pids Donar-vos la confian\u00e7a que esteu creant programari estable amb menys errors, i que el llan\u00e7ament a producci\u00f3 funciona Assegurar-vos que el vostre producte funcione en altres m\u00e0quines, no nom\u00e9s en el vostre ordinador port\u00e0til Eliminar moltes despeses generals tedioses i permet centrar-vos en all\u00f2 que importa Reduir el temps dedicat a resoldre conflictes (quan diferents persones modifiquen el mateix codi)","title":"Com sona aix\u00f2?"},{"location":"Unitats/Unitat%201/CD-CI/#conceptes-basics","text":"Hi ha diverses idees i pr\u00e0ctiques clau que cal entendre per treballar de manera efica\u00e7 amb una integraci\u00f3 cont\u00ednua. A m\u00e9s, pot haver-hi algunes paraules i frases que no coneixeu, per\u00f2 que s'utilitzen sovint quan parleu de CI. Aquest cap\u00edtol us introduir\u00e0 en aquests conceptes i l'argot que els acompanya.","title":"Conceptes b\u00e0sics"},{"location":"Unitats/Unitat%201/CD-CI/#repositori-dorigen-unic","text":"Si col\u00b7laboreu amb altres persones en una \u00fanica base de codi, \u00e9s habitual tenir un repositori compartit de codi font. Cada desenvolupador que treballa en el projecte crea una c\u00f2pia local i fa canvis. Un cop estan satisfets amb els canvis, els fusionen de nou al repositori central. S'ha convertit en un est\u00e0ndard utilitzar sistemes de control de versions (VCS) com Git per gestionar aquest flux de treball. Els equips solen utilitzar un servei extern per allotjar el seu codi font i gestionar totes les parts m\u00f2bils. Els m\u00e9s populars s\u00f3n GitHub, BitBucket i GitLab. Git us permet crear diverses branques d'un dip\u00f2sit. Cada branca \u00e9s una c\u00f2pia independent del codi font i es pot modificar sense afectar altres branques. Aquesta \u00e9s una caracter\u00edstica essencial, i la majoria dels equips tenen una branca principal (sovint anomenada branca mestra) que representa l'estat actual del projecte. Si voleu afegir o modificar codi, haur\u00edeu de crear una c\u00f2pia de la branca principal i treballar a la vostra nova branca de desenvolupament. Un cop h\u00e0giu acabat, torneu a combinar aquests canvis a la branca mestra. El control de versions inclou m\u00e9s que codi. La documentaci\u00f3 i els scripts de prova s'emmagatzemen normalment juntament amb el codi font. Alguns programes busquen fitxers externs utilitzats per configurar els seus par\u00e0metres i par\u00e0metres inicials. Altres aplicacions necessiten un esquema de base de dades. Tots aquests fitxers haurien d'anar al vostre repositori.","title":"Repositori d'origen \u00fanic"},{"location":"Unitats/Unitat%201/CD-CI/#automatitzacio-de-la-construccio","text":"Com s'ha esmentat anteriorment, construir el vostre codi significa agafar el codi font en brut, i tot el necessari per a la seva execuci\u00f3, i traduir-lo a un format que els ordinadors puguin executar directament. Python \u00e9s un llenguatge interpretat, de manera que la seva \"construcci\u00f3\" gira principalment al voltant de l'execuci\u00f3 de proves en lloc de la compilaci\u00f3. Executar aquests passos manualment despr\u00e9s de cada petit canvi \u00e9s tedi\u00f3s i requereix un temps i una atenci\u00f3 valuosos de la resoluci\u00f3 de problemes real que esteu intentant fer. Una gran part de la integraci\u00f3 cont\u00ednua \u00e9s automatitzar aquest proc\u00e9s. Qu\u00e8 significa aix\u00f2 per a Python? Penseu en un fragment de codi m\u00e9s complicat que h\u00e0giu escrit. Si heu utilitzat una biblioteca, paquet o framework que no ve amb la biblioteca est\u00e0ndard de Python (penseu qualsevol cosa que necessiteu instal\u00b7lar amb pip), Python ha de saber-ho, de manera que el programa s\u00e0piga on buscar quan trobe. ordres que no reconeix. Emmagatzemeu una llista d'aquests paquets a requirements.txt o un fitxer Pipfile. Aquestes s\u00f3n les depend\u00e8ncies del vostre codi i s\u00f3n necess\u00e0ries per a una construcci\u00f3 exitosa. Sovint escoltar\u00e0s la frase \"trencant la construcci\u00f3\". Quan trenqueu la compilaci\u00f3, vol dir que heu introdu\u00eft un canvi que va fer que el producte final no es puga utilitzar. No et preocupes. Li passa a tothom, fins i tot als desenvolupadors s\u00e8niors. Voleu evitar-ho principalment perqu\u00e8 impedir\u00e0 que tots els altres treballen. L'objectiu de CI \u00e9s que tothom treballe en una base estable coneguda. Si clonen un repositori que est\u00e0 trencant la compilaci\u00f3, treballaran amb una versi\u00f3 trencada del codi i no podran introduir ni provar els seus canvis. Quan trenqueu la construcci\u00f3, la m\u00e0xima prioritat \u00e9s arreglar-la perqu\u00e8 tothom puga reprendre la feina. Quan la compilaci\u00f3/construcci\u00f3 del software est\u00e0 automatitzada, podeu integrar canvis amb freq\u00fc\u00e8ncia, normalment diverses vegades al dia. Permet que les persones tinguen acc\u00e9s r\u00e0pidament als canvis i noten si hi ha un conflicte entre dos desenvolupadors. Si hi ha molts xicotets canvis en lloc d'unes quantes actualitzacions massives, \u00e9s molt m\u00e9s f\u00e0cil localitzar on es va originar l'error. Tamb\u00e9 us animar\u00e0 a dividir el vostre treball en trossos m\u00e9s xicotets, cosa que \u00e9s m\u00e9s f\u00e0cil de rastrejar i provar.","title":"Automatitzaci\u00f3 de la construcci\u00f3"},{"location":"Unitats/Unitat%201/CD-CI/#proves-automatitzades","text":"Com que tothom fa canvis diverses vegades al dia, \u00e9s important saber que el vostre canvi no ha trencat res m\u00e9s al codi ni ha introdu\u00eft errors. En moltes empreses, les proves s\u00f3n ara responsabilitat de tots els desenvolupadors. Si escriviu codi, haur\u00edeu d'escriure proves. Com a m\u00ednim, haur\u00edeu de cobrir totes les funcions noves amb una prova d'unitat. L'execuci\u00f3 de proves autom\u00e0ticament, amb cada canvi, \u00e9s una bona manera de detectar errors. Una prova que falla autom\u00e0ticament fa que la compilaci\u00f3 falle. Cridar\u00e0 la vostra atenci\u00f3 sobre els problemes revelats per les proves, i la compilaci\u00f3 fallida us far\u00e0 corregir l'error que heu introdu\u00eft. Les proves no garanteixen que el vostre codi estiga lliure d'errors, per\u00f2 protegeix de molts canvis descuidats. Automatitzar l'execuci\u00f3 de proves us proporciona m\u00e9s tranquil\u00b7litat perqu\u00e8 sabeu que el servidor provar\u00e0 el vostre codi cada vegada que modifiqueu el codi contra el repositori central, fins i tot si us oblideu de fer-ho localment.","title":"Proves automatitzades"},{"location":"Unitats/Unitat%201/CD-CI/#us-dun-servei-dintegracio-continua-externa","text":"Si alguna cosa funciona al vostre ordinador, funcionar\u00e0 a tots els ordinadors? Probablement no. \u00c9s una excusa clix\u00e9 (el t\u00edpic, \"al meu ordinador va\"). Fer que el codi funcione localment no \u00e9s el final de la vostra responsabilitat. Per fer front a aquest problema, la majoria de les empreses utilitzen un servei extern per gestionar la integraci\u00f3, de la mateixa manera que s'utilitza GitHub per allotjar el vostre repositori de codi font. Els serveis externs tenen servidors on creen codi i executen proves. Actuen com a monitors del vostre repositoris i impedeixen que ning\u00fa es fusione amb la branca mestra si els seus canvis trenquen la compilaci\u00f3. Hi ha molts serveis d'aquest tipus, amb diferents caracter\u00edstiques i preus. La majoria tenen un nivell gratu\u00eft perqu\u00e8 pugueu experimentar amb un dels vostres repositoris. Utilitzareu un servei anomenat en els exercis.","title":"\u00das d'un servei d'integraci\u00f3 cont\u00ednua externa"},{"location":"Unitats/Unitat%201/CD-CI/#proves-en-un-entorn-preparat","text":"Un entorn de producci\u00f3 \u00e9s on finalment s'executar\u00e0 el vostre programari. Fins i tot despr\u00e9s de crear i provar la vostra aplicaci\u00f3 amb \u00e8xit, no podeu estar segur que el vostre codi funcione a l'ordinador de destinaci\u00f3. \u00c9s per aix\u00f2 que els equips despleguen el producte final en un entorn que imite l'entorn de producci\u00f3. Una vegada esteu segur que tot funciona, l'aplicaci\u00f3 es desplega a l'entorn de producci\u00f3. Sentir\u00e0s que la gent parla d'aquest clon de l'entorn de producci\u00f3 utilitzant termes com ara entorn de desenvolupament o entorn de prova. \u00c9s habitual utilitzar abreviatures com DEV per a l'entorn de desenvolupament i PROD per a l'entorn de producci\u00f3. L'entorn de desenvolupament ha de reproduir les condicions de producci\u00f3 el m\u00e0xim possible. Aquesta configuraci\u00f3 de vegades s'anomena paritat DEV/PROD. Mantingueu l'entorn de l'ordinador local el m\u00e9s semblant possible als entorns DEV i PROD per minimitzar les anomalies en desplegar aplicacions. Estos conceptes que acabem de veure \u00e9s el que s'anomena CD (continuous deployment).","title":"Proves en un entorn preparat"},{"location":"Unitats/Unitat%201/CD-CI/#ci-amb-circleci-i-github","text":"CircleCI \u00e9s un servei per a automatitzar integracions que es pot connectar a GitHub. Necessita saber com executar la vostra contrucci\u00f3 (build) i espera que aquesta informaci\u00f3 es proporcione en un format determinat. Requereix una carpeta .circleci dins del vostre repositori i un fitxer de configuraci\u00f3 dins. El fitxer de configuraci\u00f3 cont\u00e9 instruccions per a tots els passos que el servidor de construcci\u00f3 ha d'executar. CircleCI espera que aquest fitxer es diga config.yml . Un fitxer .yml utilitza un llenguatge de serialitzaci\u00f3 de dades, YAML, i t\u00e9 la seva pr\u00f2pia especificaci\u00f3. L'objectiu de YAML \u00e9s ser llegible per l'home i funcionar b\u00e9 amb llenguatges de programaci\u00f3 moderns per a les tasques quotidianes comunes. En un fitxer YAML, hi ha tres maneres b\u00e0siques de representar dades: Mapes (parells clau-valor) Seq\u00fc\u00e8ncies (llistes) Escalars (cadenes o n\u00fameros) \u00c9s molt senzill de llegir: - El sagnat es pot utilitzar per a l'estructura. - Els dos punts separen els parells clau-valor. - Els guions s'utilitzen per crear llistes. Este seria un exemple d'aquest arxiu d'integraci\u00f3: # Python CircleCI 2.0 configuration file version: 2 jobs: build: docker: - image: circleci/python:3.7 working_directory: ~/repo steps: # Step 1: obtain repo from GitHub - checkout # Step 2: create virtual env and install dependencies - run: name: install dependencies command: | python3 -m venv venv . venv/bin/activate pip install -r requirements.txt # Step 3: run linter and tests - run: name: run tests command: | . venv/bin/activate flake8 --exclude=venv* --statistics pytest -v --cov=calculator","title":"CI amb CircleCI i GitHub"},{"location":"Unitats/Unitat%201/CD-CI/#repassem-alguns-conceptes","text":"Recordeu el problema que tenen els programadors quan alguna cosa funciona al seu ordinador port\u00e0til per\u00f2, funcionar\u00e0 a qualsevol lloc? Abans, els desenvolupadors solien crear un programa que a\u00eflla una part dels recursos f\u00edsics de l'ordinador (mem\u00f2ria, disc dur, etc.) i els converteix en una m\u00e0quina virtual. Una m\u00e0quina virtual pret\u00e9n ser tot un ordinador per si mateix. Fins i tot tindr\u00e0 el seu propi sistema operatiu. En aquest sistema operatiu, desplegueu la vostra aplicaci\u00f3 o instal\u00b7leu la vostra biblioteca i la proveu. Les m\u00e0quines virtuals ocupen molts recursos, cosa que va provocar la invenci\u00f3 dels contenidors. La idea \u00e9s an\u00e0loga als contenidors d'enviament. Abans que s'inventessin els contenidors d'enviament, els fabricants havien d'enviar mercaderies en una gran varietat de mides, embalatges i modes (camions, trens, vaixells). Mitjan\u00e7ant l'estandarditzaci\u00f3 del contenidor d'enviament, aquestes mercaderies es podrien transferir entre diferents m\u00e8todes d'enviament sense cap modificaci\u00f3. La mateixa idea s'aplica als contenidors de programari. Els contenidors s\u00f3n una unitat lleugera de codi i les seves depend\u00e8ncies en temps d'execuci\u00f3, empaquetats de manera estandarditzada, de manera que es poden connectar i executar r\u00e0pidament al sistema operatiu Linux. No cal que creeu un sistema operatiu virtual complet, com ho far\u00edeu amb una m\u00e0quina virtual. Els contenidors nom\u00e9s reprodueixen parts del sistema operatiu que necessiten per funcionar. Aix\u00f2 redueix la seva mida i els d\u00f3na un gran augment de rendiment. Docker \u00e9s actualment la plataforma de contenidors l\u00edder i fins i tot \u00e9s capa\u00e7 d'executar contenidors Linux a Windows i macOS. Per crear un contenidor Docker, necessiteu una imatge de Docker. Les imatges proporcionen pl\u00e0nols per als contenidors de la mateixa manera que les classes proporcionen pl\u00e0nols per als objectes. Reprendrem el tema de Docker m\u00e9s endavant al llarg del nostre curs. CircleCI mant\u00e9 imatges de Docker preconstru\u00efdes per a diversos llenguatges de programaci\u00f3. Al fitxer de configuraci\u00f3 anterior, heu especificat una imatge de Linux que ja t\u00e9 Python instal\u00b7lat. Aquesta imatge crear\u00e0 un contenidor dins el qual es produir\u00e0 la construcci\u00f3 del programari.","title":"Repassem alguns conceptes:"},{"location":"Unitats/Unitat%201/CD-CI/#configuracio-de-larxiu-configyml","text":"Vegem cada l\u00ednia del fitxer de configuraci\u00f3: version : cada config.yml comen\u00e7a amb el n\u00famero de versi\u00f3 de CircleCI, que s'utilitza per emetre advert\u00e8ncies sobre canvis. jobs : els treballs s\u00f3n els passos individuals que s'han de donar per a la construcci\u00f3 de l'aplicaci\u00f3. El build pot estar compost d'un sol job . build : Com s'ha dit abans, build \u00e9s el nom de la construcci\u00f3. docker : els passos d'un treball es produeixen en un entorn anomenat executor. L'executor com\u00fa de CircleCI \u00e9s un contenidor Docker. \u00c9s un entorn d'execuci\u00f3 allotjat al n\u00favol, per\u00f2 existeixen altres opcions, com ara un entorn macOS. imatge : una imatge Docker \u00e9s un fitxer utilitzat per crear un contenidor Docker en execuci\u00f3. Estem utilitzant una imatge que t\u00e9 Python 3.7 preinstal\u00b7lat. working_directory : el vostre repositori s'ha de consultar en algun lloc del servidor de compilaci\u00f3. El directori de treball representa la ruta del fitxer on s'emmagatzemar\u00e0 el repositori. steps : aquesta clau marca l'inici d'una llista de passos que ha de realitzar el servidor de compilaci\u00f3. checkout : el primer pas que ha de fer el servidor \u00e9s obtindre el codi font i portar-lo al directori de treball. Aix\u00f2 es realitza mitjan\u00e7ant un pas especial anomenat checkout . run : l'execuci\u00f3 de programes o ordres de l\u00ednia d'ordres es fa dins de la clau command . Les ordres s'executaran dins la shell del contenidor. name : la interf\u00edcie d'usuari de CircleCI us mostra cada pas de construcci\u00f3 en forma de secci\u00f3 ampliable. El t\u00edtol de la secci\u00f3 es pren del valor associat a la clau name . command : aquesta clau representa l'ordre que s'executa mitjan\u00e7ant l'int\u00e8rpret d'ordres. El s\u00edmbol | \u00e9s el car\u00e0cter que separa cadascuna de les ordres, exactament com si executarem un script de shell/bash. Per a saber m\u00e9s, consulta la seg\u00fcent guia de refer\u00e8ncia de configuraci\u00f3 de CircleCI .","title":"Configuraci\u00f3 de l'arxiu config.yml"},{"location":"Unitats/Unitat%201/CD-CI/#workflow","text":"El nostre workflow \u00e9s molt senzill i consta de 3 passos: Consulta del repositori Instal\u00b7laci\u00f3 de les depend\u00e8ncies en un entorn virtual Execuci\u00f3 del linter i proves dins de l'entorn virtual Ara tenim tot el que necessitem per iniciar el nostre pipeline . Inicieu sessi\u00f3 al vostre compte de CircleCI i feu clic a Afegeix projectes. Localitzeu el vostre repositori i feu clic a Configura el projecte. Seleccioneu Python com a llenguatge. Com que ja tenim un config.yml, podem saltar els passos seg\u00fcents i fer clic a Comen\u00e7a a crear. CircleCI us portar\u00e0 al tauler d'execuci\u00f3 de la vostra feina. Si heu seguit tots els passos correctament, haur\u00edeu de veure que la vostra feina ha passat els tests. El repositori hauria de contindre ara els vostres canvis.","title":"Workflow"},{"location":"Unitats/Unitat%201/CD-CI/#execrici-1","text":"Configura el codi de calculadora per fer una integraci\u00f3 automatitzada.","title":"Execrici 1"},{"location":"Unitats/Unitat%201/CD-CI/#fem-canvis-al-nostre-codi-i-els-integrem","text":"Hi haur\u00e0 dos tipus de canvis principalment: Afegir nova funcionalitat. Aplicarem TDD a les noves funsions i afegirem el codi validat. Refactoritzar. Comprovarem que les modificacions superen els nostres testos.","title":"Fem canvis al nostre codi i els integrem"},{"location":"Unitats/Unitat%201/CD-CI/#exercici-2","text":"Refactoritza la funci\u00f3 factorial, implementant-la de forma recursiva i afegix la nova versi\u00f3 al codi.","title":"Exercici 2"},{"location":"Unitats/Unitat%201/CD-CI/#exercici-3","text":"Afegeix una nova funci\u00f3 de c\u00e0lcul de pot\u00e8ncies a la calculadora. Fes la seua integraci\u00f3.","title":"Exercici 3"},{"location":"Unitats/Unitat%201/TDD/","text":"Basat en el material publicat a https://aulasoftwarelibre.github.io/taller-de-python/Testing/TDD/ baix llic\u00e8ncia Copyleft - CC BY-NC 4.0 - Aula de Software Libre Test Driven Developement El desenvolupament guiat per proves de programari, o Test-driven development (TDD) \u00e9s una pr\u00e0ctica d'enginyeria de programari que involucra dues pr\u00e0ctiques m\u00e9s: Escriure les proves primer (Test First Development) i Refactoritzaci\u00f3 (Refactoring). Per escriure les proves generalment es fan servir les proves unit\u00e0ries (unit test en angl\u00e8s). En primer lloc, s'escriu una prova i es verifica que la nova prova falla. A continuaci\u00f3, s'implementa el codi que fa que la prova passe satisfact\u00f2riament i tot seguit es refactoritza el codi escrit. El prop\u00f2sit del desenvolupament guiat per proves \u00e9s aconseguir un codi net que funcione. La idea \u00e9s que els requisits siguen tradu\u00efts a proves, aix\u00ed, quan les proves passen es garantir\u00e0 que el programari compleix amb els requisits que s'han establert. Com podem implementar-lo en Python? Si b\u00e9 la biblioteca est\u00e0ndard de Python ve amb unittest com a llibreria est\u00e0ndar per a proves, Pytest \u00e9s el framework de refer\u00e8ncia per provar el codi Python. Pytest fa que siga f\u00e0cil escriure, organitzar i executar proves. En comparaci\u00f3 amb unittest, de la biblioteca est\u00e0ndard de Python, Pytest: Requereix menys codi repetitiu perqu\u00e8 els seus conjunts de proves siguen m\u00e9s llegibles. Suports de la plana assertdeclaraci\u00f3 , que \u00e9s molt m\u00e9s f\u00e0cil de llegir i m\u00e9s f\u00e0cil de recordar en comparaci\u00f3 amb els assertSomethingm\u00e8todes - com assertEquals , assertTruey assertContains - en unittest. S'actualitza m\u00e9s sovint, ja que no forma part de la biblioteca est\u00e0ndard de Python. Simplifica la configuraci\u00f3 i el desmuntatge de l'estat de prova amb el sistema de fixaci\u00f3. Utilitza un enfocament funcional. A m\u00e9s, amb Pytest podem tindre un estil coherent a tots els nostres projectes de Python. Per exemple, suposem que teniu dues aplicacions web: una constru\u00efda amb Django i l'altra constru\u00efda amb Flask. Sense Pytest, el m\u00e9s probable \u00e9s que aprofitem el framework de Django juntament amb una extensi\u00f3 de Flask com Flask-Testing. Per tant, els seus conjunts de proves tindrien estils diferents. Amb Pytest, d'altra banda, tots dos conjunts de proves tindrien un estil de codi coherent, cosa que facilitaria el salt de l'un a l'altre. Pytest tamb\u00e9 t\u00e9 un gran ecosistema de complements mantingut per la comunitat. Com per exemple: Pytest-django : proporciona un conjunt de ferramentes creades espec\u00edficament per a provar aplicacions de Django Pytest-xdist : s'utilitza per a executar proves en paral\u00b7lel Pytest-cov : agrega soport de cobertura de codi Pytest-instafail : mostra fallos i errors inmediatament en lloc d'esperar fins el final d'una execuci\u00f3 Pytest El primer que hem de fer si volem utilitzar Pytest per testejar el nostre codi \u00e9s instal\u00b7lar-lo. Per aix\u00f2 obrirem una nova terminal i introduirem la seg\u00fcent ordre (fes-ho a un entorn virtual). Tal com es pot veure estem fent \u00fas de pip el gestor de paquets de Python que pr\u00e8viament hav\u00edem instal\u00b7lat. pip install pytest Una vegada fet aix\u00f2 podem comprovar la versi\u00f3 que tenim instal\u00b7lada escrivint la seg\u00fcent ordre: pytest --version I obtindr\u00edem un resultat com aquest: This is pytest version 4.6.9, imported from /usr/lib/python2.7/dist-packages/pytest.pyc Una vegada ho hem instal\u00b7lat i hem comprovat la versi\u00f3 que tenim arriba l'hora de comen\u00e7ar a fer els nostres primers tests. A l'hora d'escriure les proves cal que tant els fitxers on les escriurem com les mateixes funcions de prova dins del fitxer comencen amb el prefix test_ , ja que si no, quan cridem a pytest passant-li la ruta del directori, aquest no les trobar\u00e0. Un exemple de crida a Pytest seria una cosa aix\u00ed: pytest /home/ferran/Desktop/Curs Sintaxis El funcionament de pytest \u00e9s similar al de totes les llibreries de testing . assert Val1 == Val2 #\u00bfVal1 igual Val2? assert Val1 != Val2 #\u00bfVal1 diferente Val2? assert Val1 < Val2 #\u00bfVal1 menor que Val2? assert Val1 <= Val2 #\u00bfVal1 menor o igual que Val2? assert Val1 > Val2 #\u00bfVal1 mayor que Val2? assert Val1 >= Val2 #\u00bfVal1 mayor o igual que Val2? assert Val1 == TRUE #\u00bfVal1 igual TRUE? assert Val1 == FALSE #\u00bfVal1 igual FALSE? Exemple Suposem que hem d'implementar una calculadora. Per a aix\u00f2, definirem una s\u00e8rie de funcions que volem que estiguen disponibles a la nostra calculadora. Agafarem la funci\u00f3 suma per a continuar amb l'exemple. Si seguim al peu de la lletra les indicacions de TDD, el primer que hem de fer \u00e9s crear la funci\u00f3 buida simplement per poder cridar-la, implementar la seva prova i executar-la comprovant la falla. Per a aix\u00f2 hem de crear un nou fitxer a qui anomenem operations.py en el que definirem les funcions i crearem un fitxer anomenat test_.py on crearem la nostra funci\u00f3 test_operations () Primers passos operations.py def suma(sumad1, sumand2): return 0 test_.py import pytest import operations def test_operations(): assert operations.suma(3,3) == 6 Una vegada hem fet aix\u00f2, procedim a la refactoritzaci\u00f3 . Hem d'implementar la nostra funci\u00f3 encarregada de calcular la suma: operations.py def suma(sumand1, sumand2): return sumand1 + sumand2 Una vegada implementada, hem d'executar les proves sobre la funci\u00f3 suma: pytest test_.py I si tot ha anat b\u00e9, obtindrem un resultat similar a aquest: ===================================== comen\u00e7a la sessi\u00f3 de prova ========== ============================ plataforma linux -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/ferran/Desktop/Curs collected 1 item test_.py . [100%] ====================================== 1 passat en 0,01 s ======= ================================= Activitat 1 Acaba d'implementar les funcions resta, multiplicaci\u00f3, divisi\u00f3, arrel, exponent i factorial i el\u00b7labora els seus testos corresponents. Activitat 2 Una vegada comprovat tots els testos sobre el nostre codi, configura VSCode per a llan\u00e7ar de nou els testos r\u00e0pidament despr\u00e9s d'una refactoritzaci\u00f3.","title":"TDD"},{"location":"Unitats/Unitat%201/TDD/#test-driven-developement","text":"El desenvolupament guiat per proves de programari, o Test-driven development (TDD) \u00e9s una pr\u00e0ctica d'enginyeria de programari que involucra dues pr\u00e0ctiques m\u00e9s: Escriure les proves primer (Test First Development) i Refactoritzaci\u00f3 (Refactoring). Per escriure les proves generalment es fan servir les proves unit\u00e0ries (unit test en angl\u00e8s). En primer lloc, s'escriu una prova i es verifica que la nova prova falla. A continuaci\u00f3, s'implementa el codi que fa que la prova passe satisfact\u00f2riament i tot seguit es refactoritza el codi escrit. El prop\u00f2sit del desenvolupament guiat per proves \u00e9s aconseguir un codi net que funcione. La idea \u00e9s que els requisits siguen tradu\u00efts a proves, aix\u00ed, quan les proves passen es garantir\u00e0 que el programari compleix amb els requisits que s'han establert.","title":"Test Driven Developement"},{"location":"Unitats/Unitat%201/TDD/#com-podem-implementar-lo-en-python","text":"Si b\u00e9 la biblioteca est\u00e0ndard de Python ve amb unittest com a llibreria est\u00e0ndar per a proves, Pytest \u00e9s el framework de refer\u00e8ncia per provar el codi Python. Pytest fa que siga f\u00e0cil escriure, organitzar i executar proves. En comparaci\u00f3 amb unittest, de la biblioteca est\u00e0ndard de Python, Pytest: Requereix menys codi repetitiu perqu\u00e8 els seus conjunts de proves siguen m\u00e9s llegibles. Suports de la plana assertdeclaraci\u00f3 , que \u00e9s molt m\u00e9s f\u00e0cil de llegir i m\u00e9s f\u00e0cil de recordar en comparaci\u00f3 amb els assertSomethingm\u00e8todes - com assertEquals , assertTruey assertContains - en unittest. S'actualitza m\u00e9s sovint, ja que no forma part de la biblioteca est\u00e0ndard de Python. Simplifica la configuraci\u00f3 i el desmuntatge de l'estat de prova amb el sistema de fixaci\u00f3. Utilitza un enfocament funcional. A m\u00e9s, amb Pytest podem tindre un estil coherent a tots els nostres projectes de Python. Per exemple, suposem que teniu dues aplicacions web: una constru\u00efda amb Django i l'altra constru\u00efda amb Flask. Sense Pytest, el m\u00e9s probable \u00e9s que aprofitem el framework de Django juntament amb una extensi\u00f3 de Flask com Flask-Testing. Per tant, els seus conjunts de proves tindrien estils diferents. Amb Pytest, d'altra banda, tots dos conjunts de proves tindrien un estil de codi coherent, cosa que facilitaria el salt de l'un a l'altre. Pytest tamb\u00e9 t\u00e9 un gran ecosistema de complements mantingut per la comunitat. Com per exemple: Pytest-django : proporciona un conjunt de ferramentes creades espec\u00edficament per a provar aplicacions de Django Pytest-xdist : s'utilitza per a executar proves en paral\u00b7lel Pytest-cov : agrega soport de cobertura de codi Pytest-instafail : mostra fallos i errors inmediatament en lloc d'esperar fins el final d'una execuci\u00f3","title":"Com podem implementar-lo en Python?"},{"location":"Unitats/Unitat%201/TDD/#pytest","text":"El primer que hem de fer si volem utilitzar Pytest per testejar el nostre codi \u00e9s instal\u00b7lar-lo. Per aix\u00f2 obrirem una nova terminal i introduirem la seg\u00fcent ordre (fes-ho a un entorn virtual). Tal com es pot veure estem fent \u00fas de pip el gestor de paquets de Python que pr\u00e8viament hav\u00edem instal\u00b7lat. pip install pytest Una vegada fet aix\u00f2 podem comprovar la versi\u00f3 que tenim instal\u00b7lada escrivint la seg\u00fcent ordre: pytest --version I obtindr\u00edem un resultat com aquest: This is pytest version 4.6.9, imported from /usr/lib/python2.7/dist-packages/pytest.pyc Una vegada ho hem instal\u00b7lat i hem comprovat la versi\u00f3 que tenim arriba l'hora de comen\u00e7ar a fer els nostres primers tests. A l'hora d'escriure les proves cal que tant els fitxers on les escriurem com les mateixes funcions de prova dins del fitxer comencen amb el prefix test_ , ja que si no, quan cridem a pytest passant-li la ruta del directori, aquest no les trobar\u00e0. Un exemple de crida a Pytest seria una cosa aix\u00ed: pytest /home/ferran/Desktop/Curs","title":"Pytest"},{"location":"Unitats/Unitat%201/TDD/#sintaxis","text":"El funcionament de pytest \u00e9s similar al de totes les llibreries de testing . assert Val1 == Val2 #\u00bfVal1 igual Val2? assert Val1 != Val2 #\u00bfVal1 diferente Val2? assert Val1 < Val2 #\u00bfVal1 menor que Val2? assert Val1 <= Val2 #\u00bfVal1 menor o igual que Val2? assert Val1 > Val2 #\u00bfVal1 mayor que Val2? assert Val1 >= Val2 #\u00bfVal1 mayor o igual que Val2? assert Val1 == TRUE #\u00bfVal1 igual TRUE? assert Val1 == FALSE #\u00bfVal1 igual FALSE?","title":"Sintaxis"},{"location":"Unitats/Unitat%201/TDD/#exemple","text":"Suposem que hem d'implementar una calculadora. Per a aix\u00f2, definirem una s\u00e8rie de funcions que volem que estiguen disponibles a la nostra calculadora. Agafarem la funci\u00f3 suma per a continuar amb l'exemple. Si seguim al peu de la lletra les indicacions de TDD, el primer que hem de fer \u00e9s crear la funci\u00f3 buida simplement per poder cridar-la, implementar la seva prova i executar-la comprovant la falla. Per a aix\u00f2 hem de crear un nou fitxer a qui anomenem operations.py en el que definirem les funcions i crearem un fitxer anomenat test_.py on crearem la nostra funci\u00f3 test_operations ()","title":"Exemple"},{"location":"Unitats/Unitat%201/TDD/#primers-passos","text":"","title":"Primers passos"},{"location":"Unitats/Unitat%201/TDD/#operationspy","text":"def suma(sumad1, sumand2): return 0","title":"operations.py"},{"location":"Unitats/Unitat%201/TDD/#test_py","text":"import pytest import operations def test_operations(): assert operations.suma(3,3) == 6 Una vegada hem fet aix\u00f2, procedim a la refactoritzaci\u00f3 . Hem d'implementar la nostra funci\u00f3 encarregada de calcular la suma:","title":"test_.py"},{"location":"Unitats/Unitat%201/TDD/#operationspy_1","text":"def suma(sumand1, sumand2): return sumand1 + sumand2 Una vegada implementada, hem d'executar les proves sobre la funci\u00f3 suma: pytest test_.py I si tot ha anat b\u00e9, obtindrem un resultat similar a aquest: ===================================== comen\u00e7a la sessi\u00f3 de prova ========== ============================ plataforma linux -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/ferran/Desktop/Curs collected 1 item test_.py . [100%] ====================================== 1 passat en 0,01 s ======= =================================","title":"operations.py"},{"location":"Unitats/Unitat%201/TDD/#activitat-1","text":"Acaba d'implementar les funcions resta, multiplicaci\u00f3, divisi\u00f3, arrel, exponent i factorial i el\u00b7labora els seus testos corresponents.","title":"Activitat 1"},{"location":"Unitats/Unitat%201/TDD/#activitat-2","text":"Una vegada comprovat tots els testos sobre el nostre codi, configura VSCode per a llan\u00e7ar de nou els testos r\u00e0pidament despr\u00e9s d'una refactoritzaci\u00f3.","title":"Activitat 2"}]}