{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Benvinguts a la Web de Posada en Producci\u00f3 Segura Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna","title":"Home"},{"location":"#benvinguts-a-la-web-de-posada-en-produccio-segura","text":"Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna","title":"Benvinguts a la Web de Posada en Producci\u00f3 Segura"},{"location":"about/","text":"Sobre la web de PPS Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna Autor: Ferran Cunyat Pellicer - Departament d'Inform\u00e0tica","title":"About"},{"location":"about/#sobre-la-web-de-pps","text":"Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna Autor: Ferran Cunyat Pellicer - Departament d'Inform\u00e0tica","title":"Sobre la web de PPS"},{"location":"Unitats/Unitat%201/CD-CI/","text":"Metodologia CI/CD (integraci\u00f3 i desplegaments continus) \"La integraci\u00f3 cont\u00ednua \u00e9s una pr\u00e0ctica de desenvolupament de programari on els membres d'un equip integren el seu treball amb freq\u00fc\u00e8ncia, normalment cada persona integra almenys di\u00e0riament, donant lloc a m\u00faltiples integracions per dia. Cada integraci\u00f3 es verifica mitjan\u00e7ant una compilaci\u00f3 automatitzada (inclosa la prova) per detectar errors d'integraci\u00f3 el m\u00e9s r\u00e0pidament possible\". La programaci\u00f3 \u00e9s iterativa, \u00e9s a dir, es va repetint continuament. El codi font s'allotja a un repositori que \u00e9s compartit per tots els membres de l'equip. Si voleu treballar en aquest producte, n'heu d'obtenir una c\u00f2pia. Fareu canvis, els provareu i els tornareu a integrar al repositori principal. No fa gaire, aquestes integracions eren grans i amb setmanes (o mesos) de difer\u00e8ncia, causant mals de cap, perdre temps i perdre diners. Armats amb experi\u00e8ncia, els desenvolupadors van comen\u00e7ar a fer canvis menors i a integrar-los amb m\u00e9s freq\u00fc\u00e8ncia. Aix\u00f2 redueix les possibilitats d'introduir conflictes que cal resoldre m\u00e9s tard. Despr\u00e9s de cada integraci\u00f3, heu de crear el codi font. Construir significa transformar el vostre codi d'alt nivell en un format que el vostre ordinador sap executar. Finalment, el resultat es prova sistem\u00e0ticament per assegurar-vos que als vostres canvis no han introdu\u00eft errors. Perqu\u00e8 CD/CI? A nivell d'equip, permet una millor cultura d'enginyeria, on proporcioneu valor aviat i sovint. Es fomenta la col\u00b7laboraci\u00f3 i es detecten errors molt abans. La integraci\u00f3 cont\u00ednua permetr\u00e0: Fer que tu i el teu equip siguen m\u00e9s r\u00e0pids Donar-vos la confian\u00e7a que esteu creant programari estable amb menys errors, i que el llan\u00e7ament a producci\u00f3 funciona Assegurar-vos que el vostre producte funcione en altres m\u00e0quines, no nom\u00e9s en el vostre ordinador port\u00e0til Eliminar moltes despeses generals tedioses i permet centrar-vos en all\u00f2 que importa Reduir el temps dedicat a resoldre conflictes (quan diferents persones modifiquen el mateix codi) Conceptes b\u00e0sics Hi ha diverses idees i pr\u00e0ctiques clau que cal entendre per treballar de manera efica\u00e7 amb una integraci\u00f3 cont\u00ednua. A m\u00e9s, pot haver-hi algunes paraules i frases que no coneixeu, per\u00f2 que s'utilitzen sovint quan parleu de CI. Aquest cap\u00edtol us introduir\u00e0 en aquests conceptes i l'argot que els acompanya. Repositori d'origen \u00fanic Si col\u00b7laboreu amb altres persones en una \u00fanica base de codi, \u00e9s habitual tenir un repositori compartit de codi font. Cada desenvolupador que treballa en el projecte crea una c\u00f2pia local i fa canvis. Un cop estan satisfets amb els canvis, els fusionen de nou al repositori central. S'ha convertit en un est\u00e0ndard utilitzar sistemes de control de versions (VCS) com Git per gestionar aquest flux de treball. Els equips solen utilitzar un servei extern per allotjar el seu codi font i gestionar totes les parts m\u00f2bils. Els m\u00e9s populars s\u00f3n GitHub, BitBucket i GitLab. Git us permet crear diverses branques d'un dip\u00f2sit. Cada branca \u00e9s una c\u00f2pia independent del codi font i es pot modificar sense afectar altres branques. Aquesta \u00e9s una caracter\u00edstica essencial, i la majoria dels equips tenen una branca principal (sovint anomenada branca mestra) que representa l'estat actual del projecte. Si voleu afegir o modificar codi, haur\u00edeu de crear una c\u00f2pia de la branca principal i treballar a la vostra nova branca de desenvolupament. Un cop h\u00e0giu acabat, torneu a combinar aquests canvis a la branca mestra. El control de versions inclou m\u00e9s que codi. La documentaci\u00f3 i els scripts de prova s'emmagatzemen normalment juntament amb el codi font. Alguns programes busquen fitxers externs utilitzats per configurar els seus par\u00e0metres i par\u00e0metres inicials. Altres aplicacions necessiten un esquema de base de dades. Tots aquests fitxers haurien d'anar al vostre repositori. Automatitzaci\u00f3 de la construcci\u00f3 Com s'ha esmentat anteriorment, construir el vostre codi significa agafar el codi font en brut, i tot el necessari per a la seva execuci\u00f3, i traduir-lo a un format que els ordinadors puguin executar directament. Python \u00e9s un llenguatge interpretat, de manera que la seva \"construcci\u00f3\" gira principalment al voltant de l'execuci\u00f3 de proves en lloc de la compilaci\u00f3. Executar aquests passos manualment despr\u00e9s de cada petit canvi \u00e9s tedi\u00f3s i requereix un temps i una atenci\u00f3 valuosos de la resoluci\u00f3 de problemes real que esteu intentant fer. Una gran part de la integraci\u00f3 cont\u00ednua \u00e9s automatitzar aquest proc\u00e9s. Qu\u00e8 significa aix\u00f2 per a Python? Penseu en un fragment de codi m\u00e9s complicat que h\u00e0giu escrit. Si heu utilitzat una biblioteca, paquet o framework que no ve amb la biblioteca est\u00e0ndard de Python (penseu qualsevol cosa que necessiteu instal\u00b7lar amb pip), Python ha de saber-ho, de manera que el programa s\u00e0piga on buscar quan trobe ordres que no reconeix. Emmagatzemeu una llista d'aquests paquets a requirements.txt o un fitxer Pipfile . Aquestes s\u00f3n les depend\u00e8ncies del vostre codi i s\u00f3n necess\u00e0ries per a una construcci\u00f3 exitosa. Sovint escoltar\u00e0s la frase \"trencant la construcci\u00f3\". Quan trenqueu la compilaci\u00f3, vol dir que heu introdu\u00eft un canvi que va fer que el producte final no es puga utilitzar. No et preocupes. Li passa a tothom, fins i tot als desenvolupadors s\u00e8niors. Voleu evitar-ho principalment perqu\u00e8 impedir\u00e0 que tots els altres treballen. L'objectiu de CI \u00e9s que tothom treballe en una base estable coneguda. Si clonen un repositori que est\u00e0 trencant la compilaci\u00f3, treballaran amb una versi\u00f3 trencada del codi i no podran introduir ni provar els seus canvis. Quan trenqueu la construcci\u00f3, la m\u00e0xima prioritat \u00e9s arreglar-la perqu\u00e8 tothom puga reprendre la feina. Quan la compilaci\u00f3/construcci\u00f3 del software est\u00e0 automatitzada, podeu integrar canvis amb freq\u00fc\u00e8ncia, normalment diverses vegades al dia. Permet que les persones tinguen acc\u00e9s r\u00e0pidament als canvis i noten si hi ha un conflicte entre dos desenvolupadors. Si hi ha molts xicotets canvis en lloc d'unes quantes actualitzacions massives, \u00e9s molt m\u00e9s f\u00e0cil localitzar on es va originar l'error. Tamb\u00e9 us animar\u00e0 a dividir el vostre treball en trossos m\u00e9s xicotets, cosa que \u00e9s m\u00e9s f\u00e0cil de rastrejar i provar. Proves automatitzades Com que tothom fa canvis diverses vegades al dia, \u00e9s important saber que el vostre canvi no ha trencat res m\u00e9s al codi ni ha introdu\u00eft errors. En moltes empreses, les proves s\u00f3n ara responsabilitat de tots els desenvolupadors. Si escriviu codi, haur\u00edeu d'escriure proves. Com a m\u00ednim, haur\u00edeu de cobrir totes les funcions noves amb una prova d'unitat. L'execuci\u00f3 de proves autom\u00e0ticament, amb cada canvi, \u00e9s una bona manera de detectar errors. Una prova que falla autom\u00e0ticament fa que la compilaci\u00f3 falle. Cridar\u00e0 la vostra atenci\u00f3 sobre els problemes revelats per les proves, i la compilaci\u00f3 fallida us far\u00e0 corregir l'error que heu introdu\u00eft. Les proves no garanteixen que el vostre codi estiga lliure d'errors, per\u00f2 protegeix de molts canvis descuidats. Automatitzar l'execuci\u00f3 de proves us proporciona m\u00e9s tranquil\u00b7litat perqu\u00e8 sabeu que el servidor provar\u00e0 el vostre codi cada vegada que modifiqueu el codi contra el repositori central, fins i tot si us oblideu de fer-ho localment. \u00das d'un servei d'integraci\u00f3 cont\u00ednua externa Si alguna cosa funciona al vostre ordinador, funcionar\u00e0 a tots els ordinadors? Probablement no. \u00c9s una excusa clix\u00e9 (el t\u00edpic, \"al meu ordinador va\"). Fer que el codi funcione localment no \u00e9s el final de la vostra responsabilitat. Per fer front a aquest problema, la majoria de les empreses utilitzen un servei extern per gestionar la integraci\u00f3, de la mateixa manera que s'utilitza GitHub per allotjar el vostre repositori de codi font. Els serveis externs tenen servidors on creen codi i executen proves. Actuen com a monitors del vostre repositoris i impedeixen que ning\u00fa es fusione amb la branca mestra si els seus canvis trenquen la compilaci\u00f3. Hi ha molts serveis d'aquest tipus, amb diferents caracter\u00edstiques i preus. La majoria tenen un nivell gratu\u00eft perqu\u00e8 pugueu experimentar amb un dels vostres repositoris. Utilitzareu un servei anomenat circleci en els exercis. Proves en un entorn preparat Un entorn de producci\u00f3 \u00e9s on finalment s'executar\u00e0 el vostre programari. Fins i tot despr\u00e9s de crear i provar la vostra aplicaci\u00f3 amb \u00e8xit, no podeu estar segur que el vostre codi funcione a l'ordinador de destinaci\u00f3. \u00c9s per aix\u00f2 que els equips despleguen el producte final en un entorn que imite l'entorn de producci\u00f3. Una vegada esteu segur que tot funciona, l'aplicaci\u00f3 es desplega a l'entorn de producci\u00f3. Sentir\u00e0s que la gent parla d'aquest clon de l'entorn de producci\u00f3 utilitzant termes com ara entorn de desenvolupament o entorn de prova. \u00c9s habitual utilitzar abreviatures com DEV per a l'entorn de desenvolupament i PROD per a l'entorn de producci\u00f3. L'entorn de desenvolupament ha de reproduir les condicions de producci\u00f3 el m\u00e0xim possible. Aquesta configuraci\u00f3 de vegades s'anomena paritat DEV/PROD. Mantingueu l'entorn de l'ordinador local el m\u00e9s semblant possible als entorns DEV i PROD per minimitzar les anomalies en desplegar aplicacions. Estos conceptes que acabem de veure \u00e9s el que s'anomena CD (continuous deployment). CI amb CircleCI i GitHub CircleCI \u00e9s un servei per a automatitzar integracions que es pot connectar a GitHub. Necessita saber com executar la vostra contrucci\u00f3 (build) i espera que aquesta informaci\u00f3 es proporcione en un format determinat. Requereix una carpeta .circleci dins del vostre repositori i un fitxer de configuraci\u00f3 dins. El fitxer de configuraci\u00f3 cont\u00e9 instruccions per a tots els passos que el servidor de construcci\u00f3 ha d'executar. CircleCI espera que aquest fitxer es diga config.yml . Un fitxer .yml utilitza un llenguatge de serialitzaci\u00f3 de dades, YAML, i t\u00e9 la seva pr\u00f2pia especificaci\u00f3. L'objectiu de YAML \u00e9s ser llegible per l'home i funcionar b\u00e9 amb llenguatges de programaci\u00f3 moderns per a les tasques quotidianes comunes. En un fitxer YAML, hi ha tres maneres b\u00e0siques de representar dades: Mapes (parells clau-valor) Seq\u00fc\u00e8ncies (llistes) Escalars (cadenes o n\u00fameros) \u00c9s molt senzill de llegir: El sagnat es pot utilitzar per a l'estructura. Els dos punts separen els parells clau-valor. Els guions s'utilitzen per crear llistes. Este seria un exemple d'aquest arxiu d'integraci\u00f3: # Python CircleCI 2.0 configuration file version: 2 jobs: build: docker: - image: circleci/python:3.7 working_directory: ~/repo steps: # Step 1: obtain repo from GitHub - checkout # Step 2: create virtual env and install dependencies - run: name: install dependencies command: | python3 -m venv venv . venv/bin/activate pip install -r requirements.txt # Step 3: run linter and tests - run: name: run tests command: | . venv/bin/activate flake8 --exclude=venv* --statistics pytest -v --cov=calculator Repassem alguns conceptes: Recordeu el problema que tenen els programadors quan alguna cosa funciona al seu ordinador port\u00e0til per\u00f2, funcionar\u00e0 a qualsevol lloc? Abans, els desenvolupadors solien crear un programa que a\u00eflla una part dels recursos f\u00edsics de l'ordinador (mem\u00f2ria, disc dur, etc.) i els converteix en una m\u00e0quina virtual. Una m\u00e0quina virtual pret\u00e9n ser tot un ordinador per si mateix. Fins i tot tindr\u00e0 el seu propi sistema operatiu. En aquest sistema operatiu, desplegueu la vostra aplicaci\u00f3 o instal\u00b7leu la vostra biblioteca i la proveu. Les m\u00e0quines virtuals ocupen molts recursos, cosa que va provocar la invenci\u00f3 dels contenidors. La idea \u00e9s an\u00e0loga als contenidors d'enviament. Abans que s'inventessin els contenidors d'enviament, els fabricants havien d'enviar mercaderies en una gran varietat de mides, embalatges i modes (camions, trens, vaixells). Mitjan\u00e7ant l'estandarditzaci\u00f3 del contenidor d'enviament, aquestes mercaderies es podrien transferir entre diferents m\u00e8todes d'enviament sense cap modificaci\u00f3. La mateixa idea s'aplica als contenidors de programari. Els contenidors s\u00f3n una unitat lleugera de codi i les seves depend\u00e8ncies en temps d'execuci\u00f3, empaquetats de manera estandarditzada, de manera que es poden connectar i executar r\u00e0pidament al sistema operatiu Linux. No cal que creeu un sistema operatiu virtual complet, com ho far\u00edeu amb una m\u00e0quina virtual. Els contenidors nom\u00e9s reprodueixen parts del sistema operatiu que necessiten per funcionar. Aix\u00f2 redueix la seva mida i els d\u00f3na un gran augment de rendiment. Docker \u00e9s actualment la plataforma de contenidors l\u00edder i fins i tot \u00e9s capa\u00e7 d'executar contenidors Linux a Windows i macOS. Per crear un contenidor Docker, necessiteu una imatge de Docker. Les imatges proporcionen pl\u00e0nols per als contenidors de la mateixa manera que les classes proporcionen pl\u00e0nols per als objectes. Reprendrem el tema de Docker m\u00e9s endavant al llarg del nostre curs. CircleCI mant\u00e9 imatges de Docker preconstru\u00efdes per a diversos llenguatges de programaci\u00f3. Al fitxer de configuraci\u00f3 anterior, heu especificat una imatge de Linux que ja t\u00e9 Python instal\u00b7lat. Aquesta imatge crear\u00e0 un contenidor dins el qual es produir\u00e0 la construcci\u00f3 del programari. Configuraci\u00f3 de l'arxiu config.yml Vegem cada l\u00ednia del fitxer de configuraci\u00f3: version : cada config.yml comen\u00e7a amb el n\u00famero de versi\u00f3 de CircleCI, que s'utilitza per emetre advert\u00e8ncies sobre canvis. jobs : els treballs s\u00f3n els passos individuals que s'han de donar per a la construcci\u00f3 de l'aplicaci\u00f3. El build pot estar compost d'un sol job . build : Com s'ha dit abans, build \u00e9s el nom de la construcci\u00f3. docker : els passos d'un treball es produeixen en un entorn anomenat executor. L'executor com\u00fa de CircleCI \u00e9s un contenidor Docker. \u00c9s un entorn d'execuci\u00f3 allotjat al n\u00favol, per\u00f2 existeixen altres opcions, com ara un entorn macOS. image : una imatge Docker \u00e9s un fitxer utilitzat per crear un contenidor Docker en execuci\u00f3. Estem utilitzant una imatge que t\u00e9 Python 3.7 preinstal\u00b7lat. working_directory : el vostre repositori s'ha de consultar en algun lloc del servidor de compilaci\u00f3. El directori de treball representa la ruta del fitxer on s'emmagatzemar\u00e0 el repositori. steps : aquesta clau marca l'inici d'una llista de passos que ha de realitzar el servidor de compilaci\u00f3. checkout : el primer pas que ha de fer el servidor \u00e9s obtindre el codi font i portar-lo al directori de treball. Aix\u00f2 es realitza mitjan\u00e7ant un pas especial anomenat checkout . run : l'execuci\u00f3 de programes o ordres de l\u00ednia d'ordres es fa dins de la clau command . Les ordres s'executaran dins la shell del contenidor. name : la interf\u00edcie d'usuari de CircleCI us mostra cada pas de construcci\u00f3 en forma de secci\u00f3 ampliable. El t\u00edtol de la secci\u00f3 es pren del valor associat a la clau name . command : aquesta clau representa l'ordre que s'executa mitjan\u00e7ant l'int\u00e8rpret d'ordres. El s\u00edmbol | \u00e9s el car\u00e0cter que separa cadascuna de les ordres, exactament com si executarem un script de shell/bash. Per a saber m\u00e9s, consulta la seg\u00fcent guia de refer\u00e8ncia de configuraci\u00f3 de CircleCI . Workflow El nostre workflow \u00e9s molt senzill i consta de 3 passos: Consulta del repositori Instal\u00b7laci\u00f3 de les depend\u00e8ncies en un entorn virtual Execuci\u00f3 del linter i proves dins de l'entorn virtual Ara tenim tot el que necessitem per iniciar el nostre pipeline . Inicieu sessi\u00f3 al vostre compte de CircleCI i feu clic a Afegeix projectes. Localitzeu el vostre repositori i feu clic a Configura el projecte. Seleccioneu Python com a llenguatge. Com que ja tenim un config.yml, podem saltar els passos seg\u00fcents i fer clic a Comen\u00e7a a crear. CircleCI us portar\u00e0 al tauler d'execuci\u00f3 de la vostra feina. Si heu seguit tots els passos correctament, haur\u00edeu de veure que la vostra feina ha passat els tests. El repositori hauria de contindre ara els vostres canvis. Execrici 1 Configura el codi de calculadora per fer una integraci\u00f3 automatitzada. Fem canvis al nostre codi i els integrem Hi haur\u00e0 dos tipus de canvis principalment: Afegir nova funcionalitat. Aplicarem TDD a les noves funsions i afegirem el codi validat. Refactoritzar. Comprovarem que les modificacions superen els nostres testos. Exercici 2 Refactoritza la funci\u00f3 factorial, implementant-la de forma recursiva i afegix la nova versi\u00f3 al codi. Exercici 3 Afegeix una nova funci\u00f3 de c\u00e0lcul de pot\u00e8ncies a la calculadora. Fes la seua integraci\u00f3.","title":"CD/CI"},{"location":"Unitats/Unitat%201/CD-CI/#metodologia-cicd-integracio-i-desplegaments-continus","text":"\"La integraci\u00f3 cont\u00ednua \u00e9s una pr\u00e0ctica de desenvolupament de programari on els membres d'un equip integren el seu treball amb freq\u00fc\u00e8ncia, normalment cada persona integra almenys di\u00e0riament, donant lloc a m\u00faltiples integracions per dia. Cada integraci\u00f3 es verifica mitjan\u00e7ant una compilaci\u00f3 automatitzada (inclosa la prova) per detectar errors d'integraci\u00f3 el m\u00e9s r\u00e0pidament possible\". La programaci\u00f3 \u00e9s iterativa, \u00e9s a dir, es va repetint continuament. El codi font s'allotja a un repositori que \u00e9s compartit per tots els membres de l'equip. Si voleu treballar en aquest producte, n'heu d'obtenir una c\u00f2pia. Fareu canvis, els provareu i els tornareu a integrar al repositori principal. No fa gaire, aquestes integracions eren grans i amb setmanes (o mesos) de difer\u00e8ncia, causant mals de cap, perdre temps i perdre diners. Armats amb experi\u00e8ncia, els desenvolupadors van comen\u00e7ar a fer canvis menors i a integrar-los amb m\u00e9s freq\u00fc\u00e8ncia. Aix\u00f2 redueix les possibilitats d'introduir conflictes que cal resoldre m\u00e9s tard. Despr\u00e9s de cada integraci\u00f3, heu de crear el codi font. Construir significa transformar el vostre codi d'alt nivell en un format que el vostre ordinador sap executar. Finalment, el resultat es prova sistem\u00e0ticament per assegurar-vos que als vostres canvis no han introdu\u00eft errors.","title":"Metodologia CI/CD (integraci\u00f3 i desplegaments continus)"},{"location":"Unitats/Unitat%201/CD-CI/#perque-cdci","text":"A nivell d'equip, permet una millor cultura d'enginyeria, on proporcioneu valor aviat i sovint. Es fomenta la col\u00b7laboraci\u00f3 i es detecten errors molt abans. La integraci\u00f3 cont\u00ednua permetr\u00e0: Fer que tu i el teu equip siguen m\u00e9s r\u00e0pids Donar-vos la confian\u00e7a que esteu creant programari estable amb menys errors, i que el llan\u00e7ament a producci\u00f3 funciona Assegurar-vos que el vostre producte funcione en altres m\u00e0quines, no nom\u00e9s en el vostre ordinador port\u00e0til Eliminar moltes despeses generals tedioses i permet centrar-vos en all\u00f2 que importa Reduir el temps dedicat a resoldre conflictes (quan diferents persones modifiquen el mateix codi)","title":"Perqu\u00e8 CD/CI?"},{"location":"Unitats/Unitat%201/CD-CI/#conceptes-basics","text":"Hi ha diverses idees i pr\u00e0ctiques clau que cal entendre per treballar de manera efica\u00e7 amb una integraci\u00f3 cont\u00ednua. A m\u00e9s, pot haver-hi algunes paraules i frases que no coneixeu, per\u00f2 que s'utilitzen sovint quan parleu de CI. Aquest cap\u00edtol us introduir\u00e0 en aquests conceptes i l'argot que els acompanya.","title":"Conceptes b\u00e0sics"},{"location":"Unitats/Unitat%201/CD-CI/#repositori-dorigen-unic","text":"Si col\u00b7laboreu amb altres persones en una \u00fanica base de codi, \u00e9s habitual tenir un repositori compartit de codi font. Cada desenvolupador que treballa en el projecte crea una c\u00f2pia local i fa canvis. Un cop estan satisfets amb els canvis, els fusionen de nou al repositori central. S'ha convertit en un est\u00e0ndard utilitzar sistemes de control de versions (VCS) com Git per gestionar aquest flux de treball. Els equips solen utilitzar un servei extern per allotjar el seu codi font i gestionar totes les parts m\u00f2bils. Els m\u00e9s populars s\u00f3n GitHub, BitBucket i GitLab. Git us permet crear diverses branques d'un dip\u00f2sit. Cada branca \u00e9s una c\u00f2pia independent del codi font i es pot modificar sense afectar altres branques. Aquesta \u00e9s una caracter\u00edstica essencial, i la majoria dels equips tenen una branca principal (sovint anomenada branca mestra) que representa l'estat actual del projecte. Si voleu afegir o modificar codi, haur\u00edeu de crear una c\u00f2pia de la branca principal i treballar a la vostra nova branca de desenvolupament. Un cop h\u00e0giu acabat, torneu a combinar aquests canvis a la branca mestra. El control de versions inclou m\u00e9s que codi. La documentaci\u00f3 i els scripts de prova s'emmagatzemen normalment juntament amb el codi font. Alguns programes busquen fitxers externs utilitzats per configurar els seus par\u00e0metres i par\u00e0metres inicials. Altres aplicacions necessiten un esquema de base de dades. Tots aquests fitxers haurien d'anar al vostre repositori.","title":"Repositori d'origen \u00fanic"},{"location":"Unitats/Unitat%201/CD-CI/#automatitzacio-de-la-construccio","text":"Com s'ha esmentat anteriorment, construir el vostre codi significa agafar el codi font en brut, i tot el necessari per a la seva execuci\u00f3, i traduir-lo a un format que els ordinadors puguin executar directament. Python \u00e9s un llenguatge interpretat, de manera que la seva \"construcci\u00f3\" gira principalment al voltant de l'execuci\u00f3 de proves en lloc de la compilaci\u00f3. Executar aquests passos manualment despr\u00e9s de cada petit canvi \u00e9s tedi\u00f3s i requereix un temps i una atenci\u00f3 valuosos de la resoluci\u00f3 de problemes real que esteu intentant fer. Una gran part de la integraci\u00f3 cont\u00ednua \u00e9s automatitzar aquest proc\u00e9s. Qu\u00e8 significa aix\u00f2 per a Python? Penseu en un fragment de codi m\u00e9s complicat que h\u00e0giu escrit. Si heu utilitzat una biblioteca, paquet o framework que no ve amb la biblioteca est\u00e0ndard de Python (penseu qualsevol cosa que necessiteu instal\u00b7lar amb pip), Python ha de saber-ho, de manera que el programa s\u00e0piga on buscar quan trobe ordres que no reconeix. Emmagatzemeu una llista d'aquests paquets a requirements.txt o un fitxer Pipfile . Aquestes s\u00f3n les depend\u00e8ncies del vostre codi i s\u00f3n necess\u00e0ries per a una construcci\u00f3 exitosa. Sovint escoltar\u00e0s la frase \"trencant la construcci\u00f3\". Quan trenqueu la compilaci\u00f3, vol dir que heu introdu\u00eft un canvi que va fer que el producte final no es puga utilitzar. No et preocupes. Li passa a tothom, fins i tot als desenvolupadors s\u00e8niors. Voleu evitar-ho principalment perqu\u00e8 impedir\u00e0 que tots els altres treballen. L'objectiu de CI \u00e9s que tothom treballe en una base estable coneguda. Si clonen un repositori que est\u00e0 trencant la compilaci\u00f3, treballaran amb una versi\u00f3 trencada del codi i no podran introduir ni provar els seus canvis. Quan trenqueu la construcci\u00f3, la m\u00e0xima prioritat \u00e9s arreglar-la perqu\u00e8 tothom puga reprendre la feina. Quan la compilaci\u00f3/construcci\u00f3 del software est\u00e0 automatitzada, podeu integrar canvis amb freq\u00fc\u00e8ncia, normalment diverses vegades al dia. Permet que les persones tinguen acc\u00e9s r\u00e0pidament als canvis i noten si hi ha un conflicte entre dos desenvolupadors. Si hi ha molts xicotets canvis en lloc d'unes quantes actualitzacions massives, \u00e9s molt m\u00e9s f\u00e0cil localitzar on es va originar l'error. Tamb\u00e9 us animar\u00e0 a dividir el vostre treball en trossos m\u00e9s xicotets, cosa que \u00e9s m\u00e9s f\u00e0cil de rastrejar i provar.","title":"Automatitzaci\u00f3 de la construcci\u00f3"},{"location":"Unitats/Unitat%201/CD-CI/#proves-automatitzades","text":"Com que tothom fa canvis diverses vegades al dia, \u00e9s important saber que el vostre canvi no ha trencat res m\u00e9s al codi ni ha introdu\u00eft errors. En moltes empreses, les proves s\u00f3n ara responsabilitat de tots els desenvolupadors. Si escriviu codi, haur\u00edeu d'escriure proves. Com a m\u00ednim, haur\u00edeu de cobrir totes les funcions noves amb una prova d'unitat. L'execuci\u00f3 de proves autom\u00e0ticament, amb cada canvi, \u00e9s una bona manera de detectar errors. Una prova que falla autom\u00e0ticament fa que la compilaci\u00f3 falle. Cridar\u00e0 la vostra atenci\u00f3 sobre els problemes revelats per les proves, i la compilaci\u00f3 fallida us far\u00e0 corregir l'error que heu introdu\u00eft. Les proves no garanteixen que el vostre codi estiga lliure d'errors, per\u00f2 protegeix de molts canvis descuidats. Automatitzar l'execuci\u00f3 de proves us proporciona m\u00e9s tranquil\u00b7litat perqu\u00e8 sabeu que el servidor provar\u00e0 el vostre codi cada vegada que modifiqueu el codi contra el repositori central, fins i tot si us oblideu de fer-ho localment.","title":"Proves automatitzades"},{"location":"Unitats/Unitat%201/CD-CI/#us-dun-servei-dintegracio-continua-externa","text":"Si alguna cosa funciona al vostre ordinador, funcionar\u00e0 a tots els ordinadors? Probablement no. \u00c9s una excusa clix\u00e9 (el t\u00edpic, \"al meu ordinador va\"). Fer que el codi funcione localment no \u00e9s el final de la vostra responsabilitat. Per fer front a aquest problema, la majoria de les empreses utilitzen un servei extern per gestionar la integraci\u00f3, de la mateixa manera que s'utilitza GitHub per allotjar el vostre repositori de codi font. Els serveis externs tenen servidors on creen codi i executen proves. Actuen com a monitors del vostre repositoris i impedeixen que ning\u00fa es fusione amb la branca mestra si els seus canvis trenquen la compilaci\u00f3. Hi ha molts serveis d'aquest tipus, amb diferents caracter\u00edstiques i preus. La majoria tenen un nivell gratu\u00eft perqu\u00e8 pugueu experimentar amb un dels vostres repositoris. Utilitzareu un servei anomenat circleci en els exercis.","title":"\u00das d'un servei d'integraci\u00f3 cont\u00ednua externa"},{"location":"Unitats/Unitat%201/CD-CI/#proves-en-un-entorn-preparat","text":"Un entorn de producci\u00f3 \u00e9s on finalment s'executar\u00e0 el vostre programari. Fins i tot despr\u00e9s de crear i provar la vostra aplicaci\u00f3 amb \u00e8xit, no podeu estar segur que el vostre codi funcione a l'ordinador de destinaci\u00f3. \u00c9s per aix\u00f2 que els equips despleguen el producte final en un entorn que imite l'entorn de producci\u00f3. Una vegada esteu segur que tot funciona, l'aplicaci\u00f3 es desplega a l'entorn de producci\u00f3. Sentir\u00e0s que la gent parla d'aquest clon de l'entorn de producci\u00f3 utilitzant termes com ara entorn de desenvolupament o entorn de prova. \u00c9s habitual utilitzar abreviatures com DEV per a l'entorn de desenvolupament i PROD per a l'entorn de producci\u00f3. L'entorn de desenvolupament ha de reproduir les condicions de producci\u00f3 el m\u00e0xim possible. Aquesta configuraci\u00f3 de vegades s'anomena paritat DEV/PROD. Mantingueu l'entorn de l'ordinador local el m\u00e9s semblant possible als entorns DEV i PROD per minimitzar les anomalies en desplegar aplicacions. Estos conceptes que acabem de veure \u00e9s el que s'anomena CD (continuous deployment).","title":"Proves en un entorn preparat"},{"location":"Unitats/Unitat%201/CD-CI/#ci-amb-circleci-i-github","text":"CircleCI \u00e9s un servei per a automatitzar integracions que es pot connectar a GitHub. Necessita saber com executar la vostra contrucci\u00f3 (build) i espera que aquesta informaci\u00f3 es proporcione en un format determinat. Requereix una carpeta .circleci dins del vostre repositori i un fitxer de configuraci\u00f3 dins. El fitxer de configuraci\u00f3 cont\u00e9 instruccions per a tots els passos que el servidor de construcci\u00f3 ha d'executar. CircleCI espera que aquest fitxer es diga config.yml . Un fitxer .yml utilitza un llenguatge de serialitzaci\u00f3 de dades, YAML, i t\u00e9 la seva pr\u00f2pia especificaci\u00f3. L'objectiu de YAML \u00e9s ser llegible per l'home i funcionar b\u00e9 amb llenguatges de programaci\u00f3 moderns per a les tasques quotidianes comunes. En un fitxer YAML, hi ha tres maneres b\u00e0siques de representar dades: Mapes (parells clau-valor) Seq\u00fc\u00e8ncies (llistes) Escalars (cadenes o n\u00fameros) \u00c9s molt senzill de llegir: El sagnat es pot utilitzar per a l'estructura. Els dos punts separen els parells clau-valor. Els guions s'utilitzen per crear llistes. Este seria un exemple d'aquest arxiu d'integraci\u00f3: # Python CircleCI 2.0 configuration file version: 2 jobs: build: docker: - image: circleci/python:3.7 working_directory: ~/repo steps: # Step 1: obtain repo from GitHub - checkout # Step 2: create virtual env and install dependencies - run: name: install dependencies command: | python3 -m venv venv . venv/bin/activate pip install -r requirements.txt # Step 3: run linter and tests - run: name: run tests command: | . venv/bin/activate flake8 --exclude=venv* --statistics pytest -v --cov=calculator","title":"CI amb CircleCI i GitHub"},{"location":"Unitats/Unitat%201/CD-CI/#repassem-alguns-conceptes","text":"Recordeu el problema que tenen els programadors quan alguna cosa funciona al seu ordinador port\u00e0til per\u00f2, funcionar\u00e0 a qualsevol lloc? Abans, els desenvolupadors solien crear un programa que a\u00eflla una part dels recursos f\u00edsics de l'ordinador (mem\u00f2ria, disc dur, etc.) i els converteix en una m\u00e0quina virtual. Una m\u00e0quina virtual pret\u00e9n ser tot un ordinador per si mateix. Fins i tot tindr\u00e0 el seu propi sistema operatiu. En aquest sistema operatiu, desplegueu la vostra aplicaci\u00f3 o instal\u00b7leu la vostra biblioteca i la proveu. Les m\u00e0quines virtuals ocupen molts recursos, cosa que va provocar la invenci\u00f3 dels contenidors. La idea \u00e9s an\u00e0loga als contenidors d'enviament. Abans que s'inventessin els contenidors d'enviament, els fabricants havien d'enviar mercaderies en una gran varietat de mides, embalatges i modes (camions, trens, vaixells). Mitjan\u00e7ant l'estandarditzaci\u00f3 del contenidor d'enviament, aquestes mercaderies es podrien transferir entre diferents m\u00e8todes d'enviament sense cap modificaci\u00f3. La mateixa idea s'aplica als contenidors de programari. Els contenidors s\u00f3n una unitat lleugera de codi i les seves depend\u00e8ncies en temps d'execuci\u00f3, empaquetats de manera estandarditzada, de manera que es poden connectar i executar r\u00e0pidament al sistema operatiu Linux. No cal que creeu un sistema operatiu virtual complet, com ho far\u00edeu amb una m\u00e0quina virtual. Els contenidors nom\u00e9s reprodueixen parts del sistema operatiu que necessiten per funcionar. Aix\u00f2 redueix la seva mida i els d\u00f3na un gran augment de rendiment. Docker \u00e9s actualment la plataforma de contenidors l\u00edder i fins i tot \u00e9s capa\u00e7 d'executar contenidors Linux a Windows i macOS. Per crear un contenidor Docker, necessiteu una imatge de Docker. Les imatges proporcionen pl\u00e0nols per als contenidors de la mateixa manera que les classes proporcionen pl\u00e0nols per als objectes. Reprendrem el tema de Docker m\u00e9s endavant al llarg del nostre curs. CircleCI mant\u00e9 imatges de Docker preconstru\u00efdes per a diversos llenguatges de programaci\u00f3. Al fitxer de configuraci\u00f3 anterior, heu especificat una imatge de Linux que ja t\u00e9 Python instal\u00b7lat. Aquesta imatge crear\u00e0 un contenidor dins el qual es produir\u00e0 la construcci\u00f3 del programari.","title":"Repassem alguns conceptes:"},{"location":"Unitats/Unitat%201/CD-CI/#configuracio-de-larxiu-configyml","text":"Vegem cada l\u00ednia del fitxer de configuraci\u00f3: version : cada config.yml comen\u00e7a amb el n\u00famero de versi\u00f3 de CircleCI, que s'utilitza per emetre advert\u00e8ncies sobre canvis. jobs : els treballs s\u00f3n els passos individuals que s'han de donar per a la construcci\u00f3 de l'aplicaci\u00f3. El build pot estar compost d'un sol job . build : Com s'ha dit abans, build \u00e9s el nom de la construcci\u00f3. docker : els passos d'un treball es produeixen en un entorn anomenat executor. L'executor com\u00fa de CircleCI \u00e9s un contenidor Docker. \u00c9s un entorn d'execuci\u00f3 allotjat al n\u00favol, per\u00f2 existeixen altres opcions, com ara un entorn macOS. image : una imatge Docker \u00e9s un fitxer utilitzat per crear un contenidor Docker en execuci\u00f3. Estem utilitzant una imatge que t\u00e9 Python 3.7 preinstal\u00b7lat. working_directory : el vostre repositori s'ha de consultar en algun lloc del servidor de compilaci\u00f3. El directori de treball representa la ruta del fitxer on s'emmagatzemar\u00e0 el repositori. steps : aquesta clau marca l'inici d'una llista de passos que ha de realitzar el servidor de compilaci\u00f3. checkout : el primer pas que ha de fer el servidor \u00e9s obtindre el codi font i portar-lo al directori de treball. Aix\u00f2 es realitza mitjan\u00e7ant un pas especial anomenat checkout . run : l'execuci\u00f3 de programes o ordres de l\u00ednia d'ordres es fa dins de la clau command . Les ordres s'executaran dins la shell del contenidor. name : la interf\u00edcie d'usuari de CircleCI us mostra cada pas de construcci\u00f3 en forma de secci\u00f3 ampliable. El t\u00edtol de la secci\u00f3 es pren del valor associat a la clau name . command : aquesta clau representa l'ordre que s'executa mitjan\u00e7ant l'int\u00e8rpret d'ordres. El s\u00edmbol | \u00e9s el car\u00e0cter que separa cadascuna de les ordres, exactament com si executarem un script de shell/bash. Per a saber m\u00e9s, consulta la seg\u00fcent guia de refer\u00e8ncia de configuraci\u00f3 de CircleCI .","title":"Configuraci\u00f3 de l'arxiu config.yml"},{"location":"Unitats/Unitat%201/CD-CI/#workflow","text":"El nostre workflow \u00e9s molt senzill i consta de 3 passos: Consulta del repositori Instal\u00b7laci\u00f3 de les depend\u00e8ncies en un entorn virtual Execuci\u00f3 del linter i proves dins de l'entorn virtual Ara tenim tot el que necessitem per iniciar el nostre pipeline . Inicieu sessi\u00f3 al vostre compte de CircleCI i feu clic a Afegeix projectes. Localitzeu el vostre repositori i feu clic a Configura el projecte. Seleccioneu Python com a llenguatge. Com que ja tenim un config.yml, podem saltar els passos seg\u00fcents i fer clic a Comen\u00e7a a crear. CircleCI us portar\u00e0 al tauler d'execuci\u00f3 de la vostra feina. Si heu seguit tots els passos correctament, haur\u00edeu de veure que la vostra feina ha passat els tests. El repositori hauria de contindre ara els vostres canvis.","title":"Workflow"},{"location":"Unitats/Unitat%201/CD-CI/#execrici-1","text":"Configura el codi de calculadora per fer una integraci\u00f3 automatitzada.","title":"Execrici 1"},{"location":"Unitats/Unitat%201/CD-CI/#fem-canvis-al-nostre-codi-i-els-integrem","text":"Hi haur\u00e0 dos tipus de canvis principalment: Afegir nova funcionalitat. Aplicarem TDD a les noves funsions i afegirem el codi validat. Refactoritzar. Comprovarem que les modificacions superen els nostres testos.","title":"Fem canvis al nostre codi i els integrem"},{"location":"Unitats/Unitat%201/CD-CI/#exercici-2","text":"Refactoritza la funci\u00f3 factorial, implementant-la de forma recursiva i afegix la nova versi\u00f3 al codi.","title":"Exercici 2"},{"location":"Unitats/Unitat%201/CD-CI/#exercici-3","text":"Afegeix una nova funci\u00f3 de c\u00e0lcul de pot\u00e8ncies a la calculadora. Fes la seua integraci\u00f3.","title":"Exercici 3"},{"location":"Unitats/Unitat%201/TDD/","text":"Basat en el material publicat a https://aulasoftwarelibre.github.io/taller-de-python/Testing/TDD/ baix llic\u00e8ncia Copyleft - CC BY-NC 4.0 - Aula de Software Libre Test Driven Developement El desenvolupament guiat per proves de programari, o Test-driven development (TDD) \u00e9s una pr\u00e0ctica d'enginyeria de programari que involucra dues pr\u00e0ctiques m\u00e9s: Escriure les proves primer (Test First Development) i Refactoritzaci\u00f3 (Refactoring). Per escriure les proves generalment es fan servir les proves unit\u00e0ries (unit test en angl\u00e8s). En primer lloc, s'escriu una prova i es verifica que la nova prova falla. A continuaci\u00f3, s'implementa el codi que fa que la prova passe satisfact\u00f2riament i tot seguit es refactoritza el codi escrit. El prop\u00f2sit del desenvolupament guiat per proves \u00e9s aconseguir un codi net que funcione. La idea \u00e9s que els requisits siguen tradu\u00efts a proves, aix\u00ed, quan les proves passen es garantir\u00e0 que el programari compleix amb els requisits que s'han establert. Com podem implementar-lo en Python? Si b\u00e9 la biblioteca est\u00e0ndard de Python ve amb unittest com a llibreria est\u00e0ndar per a proves, Pytest \u00e9s el framework de refer\u00e8ncia per provar el codi Python. Pytest fa que siga f\u00e0cil escriure, organitzar i executar proves. En comparaci\u00f3 amb unittest, de la biblioteca est\u00e0ndard de Python, Pytest: Requereix menys codi repetitiu perqu\u00e8 els seus conjunts de proves siguen m\u00e9s llegibles. Suports de la plana assertdeclaraci\u00f3 , que \u00e9s molt m\u00e9s f\u00e0cil de llegir i m\u00e9s f\u00e0cil de recordar en comparaci\u00f3 amb els assertSomethingm\u00e8todes - com assertEquals , assertTruey assertContains - en unittest. S'actualitza m\u00e9s sovint, ja que no forma part de la biblioteca est\u00e0ndard de Python. Simplifica la configuraci\u00f3 i el desmuntatge de l'estat de prova amb el sistema de fixaci\u00f3. Utilitza un enfocament funcional. A m\u00e9s, amb Pytest podem tindre un estil coherent a tots els nostres projectes de Python. Per exemple, suposem que teniu dues aplicacions web: una constru\u00efda amb Django i l'altra constru\u00efda amb Flask. Sense Pytest, el m\u00e9s probable \u00e9s que aprofitem el framework de Django juntament amb una extensi\u00f3 de Flask com Flask-Testing. Per tant, els seus conjunts de proves tindrien estils diferents. Amb Pytest, d'altra banda, tots dos conjunts de proves tindrien un estil de codi coherent, cosa que facilitaria el salt de l'un a l'altre. Pytest tamb\u00e9 t\u00e9 un gran ecosistema de complements mantingut per la comunitat. Com per exemple: Pytest-django : proporciona un conjunt de ferramentes creades espec\u00edficament per a provar aplicacions de Django Pytest-xdist : s'utilitza per a executar proves en paral\u00b7lel Pytest-cov : agrega soport de cobertura de codi Pytest-instafail : mostra fallos i errors inmediatament en lloc d'esperar fins el final d'una execuci\u00f3 Pytest El primer que hem de fer si volem utilitzar Pytest per testejar el nostre codi \u00e9s instal\u00b7lar-lo. Per aix\u00f2 obrirem una nova terminal i introduirem la seg\u00fcent ordre (fes-ho a un entorn virtual). Tal com es pot veure estem fent \u00fas de pip el gestor de paquets de Python que pr\u00e8viament hav\u00edem instal\u00b7lat. pip install pytest Una vegada fet aix\u00f2 podem comprovar la versi\u00f3 que tenim instal\u00b7lada escrivint la seg\u00fcent ordre: pytest --version I obtindr\u00edem un resultat com aquest: This is pytest version 4.6.9, imported from /usr/lib/python2.7/dist-packages/pytest.pyc Una vegada ho hem instal\u00b7lat i hem comprovat la versi\u00f3 que tenim arriba l'hora de comen\u00e7ar a fer els nostres primers tests. A l'hora d'escriure les proves cal que tant els fitxers on les escriurem com les mateixes funcions de prova dins del fitxer comencen amb el prefix test_ , ja que si no, quan cridem a pytest passant-li la ruta del directori, aquest no les trobar\u00e0. Un exemple de crida a Pytest seria una cosa aix\u00ed: pytest /home/ferran/Desktop/Curs Sintaxis El funcionament de pytest \u00e9s similar al de totes les llibreries de testing . assert Val1 == Val2 #\u00bfVal1 igual Val2? assert Val1 != Val2 #\u00bfVal1 diferente Val2? assert Val1 < Val2 #\u00bfVal1 menor que Val2? assert Val1 <= Val2 #\u00bfVal1 menor o igual que Val2? assert Val1 > Val2 #\u00bfVal1 mayor que Val2? assert Val1 >= Val2 #\u00bfVal1 mayor o igual que Val2? assert Val1 == TRUE #\u00bfVal1 igual TRUE? assert Val1 == FALSE #\u00bfVal1 igual FALSE? Exemple Suposem que hem d'implementar una calculadora. Per a aix\u00f2, definirem una s\u00e8rie de funcions que volem que estiguen disponibles a la nostra calculadora. Agafarem la funci\u00f3 suma per a continuar amb l'exemple. Si seguim al peu de la lletra les indicacions de TDD, el primer que hem de fer \u00e9s crear la funci\u00f3 buida simplement per poder cridar-la, implementar la seva prova i executar-la comprovant la falla. Per a aix\u00f2 hem de crear un nou fitxer a qui anomenem operations.py en el que definirem les funcions i crearem un fitxer anomenat test_.py on crearem la nostra funci\u00f3 test_operations () Primers passos operations.py def suma(sumad1, sumand2): return 0 test_.py import pytest import operations def test_operations(): assert operations.suma(3,3) == 6 Una vegada hem fet aix\u00f2, procedim a la refactoritzaci\u00f3 . Hem d'implementar la nostra funci\u00f3 encarregada de calcular la suma: operations.py def suma(sumand1, sumand2): return sumand1 + sumand2 Una vegada implementada, hem d'executar les proves sobre la funci\u00f3 suma: pytest test_.py I si tot ha anat b\u00e9, obtindrem un resultat similar a aquest: ===================================== comen\u00e7a la sessi\u00f3 de prova ========== ============================ plataforma linux -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/ferran/Desktop/Curs collected 1 item test_.py . [100%] ====================================== 1 passat en 0,01 s ======= ================================= Activitat 1 Acaba d'implementar les funcions resta, multiplicaci\u00f3, divisi\u00f3, arrel, exponent i factorial i el\u00b7labora els seus testos corresponents. Activitat 2 Una vegada comprovat tots els testos sobre el nostre codi, configura VSCode per a llan\u00e7ar de nou els testos r\u00e0pidament despr\u00e9s d'una refactoritzaci\u00f3.","title":"TDD"},{"location":"Unitats/Unitat%201/TDD/#test-driven-developement","text":"El desenvolupament guiat per proves de programari, o Test-driven development (TDD) \u00e9s una pr\u00e0ctica d'enginyeria de programari que involucra dues pr\u00e0ctiques m\u00e9s: Escriure les proves primer (Test First Development) i Refactoritzaci\u00f3 (Refactoring). Per escriure les proves generalment es fan servir les proves unit\u00e0ries (unit test en angl\u00e8s). En primer lloc, s'escriu una prova i es verifica que la nova prova falla. A continuaci\u00f3, s'implementa el codi que fa que la prova passe satisfact\u00f2riament i tot seguit es refactoritza el codi escrit. El prop\u00f2sit del desenvolupament guiat per proves \u00e9s aconseguir un codi net que funcione. La idea \u00e9s que els requisits siguen tradu\u00efts a proves, aix\u00ed, quan les proves passen es garantir\u00e0 que el programari compleix amb els requisits que s'han establert.","title":"Test Driven Developement"},{"location":"Unitats/Unitat%201/TDD/#com-podem-implementar-lo-en-python","text":"Si b\u00e9 la biblioteca est\u00e0ndard de Python ve amb unittest com a llibreria est\u00e0ndar per a proves, Pytest \u00e9s el framework de refer\u00e8ncia per provar el codi Python. Pytest fa que siga f\u00e0cil escriure, organitzar i executar proves. En comparaci\u00f3 amb unittest, de la biblioteca est\u00e0ndard de Python, Pytest: Requereix menys codi repetitiu perqu\u00e8 els seus conjunts de proves siguen m\u00e9s llegibles. Suports de la plana assertdeclaraci\u00f3 , que \u00e9s molt m\u00e9s f\u00e0cil de llegir i m\u00e9s f\u00e0cil de recordar en comparaci\u00f3 amb els assertSomethingm\u00e8todes - com assertEquals , assertTruey assertContains - en unittest. S'actualitza m\u00e9s sovint, ja que no forma part de la biblioteca est\u00e0ndard de Python. Simplifica la configuraci\u00f3 i el desmuntatge de l'estat de prova amb el sistema de fixaci\u00f3. Utilitza un enfocament funcional. A m\u00e9s, amb Pytest podem tindre un estil coherent a tots els nostres projectes de Python. Per exemple, suposem que teniu dues aplicacions web: una constru\u00efda amb Django i l'altra constru\u00efda amb Flask. Sense Pytest, el m\u00e9s probable \u00e9s que aprofitem el framework de Django juntament amb una extensi\u00f3 de Flask com Flask-Testing. Per tant, els seus conjunts de proves tindrien estils diferents. Amb Pytest, d'altra banda, tots dos conjunts de proves tindrien un estil de codi coherent, cosa que facilitaria el salt de l'un a l'altre. Pytest tamb\u00e9 t\u00e9 un gran ecosistema de complements mantingut per la comunitat. Com per exemple: Pytest-django : proporciona un conjunt de ferramentes creades espec\u00edficament per a provar aplicacions de Django Pytest-xdist : s'utilitza per a executar proves en paral\u00b7lel Pytest-cov : agrega soport de cobertura de codi Pytest-instafail : mostra fallos i errors inmediatament en lloc d'esperar fins el final d'una execuci\u00f3","title":"Com podem implementar-lo en Python?"},{"location":"Unitats/Unitat%201/TDD/#pytest","text":"El primer que hem de fer si volem utilitzar Pytest per testejar el nostre codi \u00e9s instal\u00b7lar-lo. Per aix\u00f2 obrirem una nova terminal i introduirem la seg\u00fcent ordre (fes-ho a un entorn virtual). Tal com es pot veure estem fent \u00fas de pip el gestor de paquets de Python que pr\u00e8viament hav\u00edem instal\u00b7lat. pip install pytest Una vegada fet aix\u00f2 podem comprovar la versi\u00f3 que tenim instal\u00b7lada escrivint la seg\u00fcent ordre: pytest --version I obtindr\u00edem un resultat com aquest: This is pytest version 4.6.9, imported from /usr/lib/python2.7/dist-packages/pytest.pyc Una vegada ho hem instal\u00b7lat i hem comprovat la versi\u00f3 que tenim arriba l'hora de comen\u00e7ar a fer els nostres primers tests. A l'hora d'escriure les proves cal que tant els fitxers on les escriurem com les mateixes funcions de prova dins del fitxer comencen amb el prefix test_ , ja que si no, quan cridem a pytest passant-li la ruta del directori, aquest no les trobar\u00e0. Un exemple de crida a Pytest seria una cosa aix\u00ed: pytest /home/ferran/Desktop/Curs","title":"Pytest"},{"location":"Unitats/Unitat%201/TDD/#sintaxis","text":"El funcionament de pytest \u00e9s similar al de totes les llibreries de testing . assert Val1 == Val2 #\u00bfVal1 igual Val2? assert Val1 != Val2 #\u00bfVal1 diferente Val2? assert Val1 < Val2 #\u00bfVal1 menor que Val2? assert Val1 <= Val2 #\u00bfVal1 menor o igual que Val2? assert Val1 > Val2 #\u00bfVal1 mayor que Val2? assert Val1 >= Val2 #\u00bfVal1 mayor o igual que Val2? assert Val1 == TRUE #\u00bfVal1 igual TRUE? assert Val1 == FALSE #\u00bfVal1 igual FALSE?","title":"Sintaxis"},{"location":"Unitats/Unitat%201/TDD/#exemple","text":"Suposem que hem d'implementar una calculadora. Per a aix\u00f2, definirem una s\u00e8rie de funcions que volem que estiguen disponibles a la nostra calculadora. Agafarem la funci\u00f3 suma per a continuar amb l'exemple. Si seguim al peu de la lletra les indicacions de TDD, el primer que hem de fer \u00e9s crear la funci\u00f3 buida simplement per poder cridar-la, implementar la seva prova i executar-la comprovant la falla. Per a aix\u00f2 hem de crear un nou fitxer a qui anomenem operations.py en el que definirem les funcions i crearem un fitxer anomenat test_.py on crearem la nostra funci\u00f3 test_operations ()","title":"Exemple"},{"location":"Unitats/Unitat%201/TDD/#primers-passos","text":"","title":"Primers passos"},{"location":"Unitats/Unitat%201/TDD/#operationspy","text":"def suma(sumad1, sumand2): return 0","title":"operations.py"},{"location":"Unitats/Unitat%201/TDD/#test_py","text":"import pytest import operations def test_operations(): assert operations.suma(3,3) == 6 Una vegada hem fet aix\u00f2, procedim a la refactoritzaci\u00f3 . Hem d'implementar la nostra funci\u00f3 encarregada de calcular la suma:","title":"test_.py"},{"location":"Unitats/Unitat%201/TDD/#operationspy_1","text":"def suma(sumand1, sumand2): return sumand1 + sumand2 Una vegada implementada, hem d'executar les proves sobre la funci\u00f3 suma: pytest test_.py I si tot ha anat b\u00e9, obtindrem un resultat similar a aquest: ===================================== comen\u00e7a la sessi\u00f3 de prova ========== ============================ plataforma linux -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/ferran/Desktop/Curs collected 1 item test_.py . [100%] ====================================== 1 passat en 0,01 s ======= =================================","title":"operations.py"},{"location":"Unitats/Unitat%201/TDD/#activitat-1","text":"Acaba d'implementar les funcions resta, multiplicaci\u00f3, divisi\u00f3, arrel, exponent i factorial i el\u00b7labora els seus testos corresponents.","title":"Activitat 1"},{"location":"Unitats/Unitat%201/TDD/#activitat-2","text":"Una vegada comprovat tots els testos sobre el nostre codi, configura VSCode per a llan\u00e7ar de nou els testos r\u00e0pidament despr\u00e9s d'una refactoritzaci\u00f3.","title":"Activitat 2"},{"location":"Unitats/Unitat%203/APIRest/","text":"Construim una API Rest amb Node.js, SQLite i Express JS En esta pr\u00e0ctica construirem una API Rest utilitzant Node.js, SQLite i Express.js. Els principals components de la nostra API seran: El projecte Node.js creat amb NPM Un servidor web creat amb Express.js per a gestionar els endpoints, les peticiions i les respostes Una base de dades SQLite per a guardar la informaci\u00f3 del backend Les aplicacions reals no utilitzen normalment SQLite, per\u00f2 ho fem aix\u00ed ja que d'esta forma ens estalviem tindre que configurar un sistema gestor de base de dades com puga ser MySQL. Requisits previs Abans de comen\u00e7ar necessitem instal\u00b7lar Node.js i git per a crear un repositori local. Projecte Node.js Per comen\u00e7ar amb el nostre projecte, crearem una carpeta i iniciarem un projecte amb npm: mkdir APIRest-node-express-SQLite cd APIRest-node-express-SQLite npm init NPM ens demanar\u00e0 informaci\u00f3 sobre el nostre projecte. Els camps m\u00e9s importants s\u00f3n el package name i l' entry point . En el nostre cas, el punt d'entrada d'execuci\u00f3 del projecte ser\u00e0 un arxiu anomenat server.js (el nostre servidor Express.js). { \"name\": \"apirest-node-express-sqlite\", \"version\": \"1.0.0\", \"description\": \"APIRest amb nodejs, express i sqlite.\", \"main\": \"server.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"Ferran Cunyat Pellicer\", \"license\": \"GPL-3.0-or-later\" } Amb npm instal\u00b7lem algunes depend\u00e8ncies que necessitem: npm install express sqlite3 md5 npm install --save-dev nodemon Si observes l'arxiu package.json veur\u00e0s que se'ns han afegit estes depend\u00e8ncies. Creeu un repositori de github tamb\u00e9 per guardar el vostre codi. Recordeu afegir node_modules al vostre .gitignore . echo node_modules > .gitignore git init -b main git add . git commit -m \"Primer commit\" git remote add origin <URL_REMOTA> git remote -v git push origin main El servidor Express.js Ara podem crear el nostre script principal server.js que servir\u00e0 de punt d'entrada al servidor utilitzant express.js. Expresss.js ens permet en poques l\u00ednies tindre un servidor web funcionant: // Create express app var express = require(\"express\") var app = express() // Server port var HTTP_PORT = 9000 // Start server app.listen(HTTP_PORT, () => { console.log(\"Servidor escoltant a l'adre\u00e7a http://localhost:%PORT%\".replace(\"%PORT%\",HTTP_PORT)) }); // Root endpoint app.get(\"/\", (req, res, next) => { res.json({\"message\":\"Ok\"}) }); // Insert here other API endpoints // Default response for any other request // Default response for any other request app.use(function (req, res) { res.status(404).json({ \"error\": \"Invalid endpoint\" }); }); En el codi podem identificar alguns punts importants: El servidor express (app) El port sobre el que escolta el servidor (HTTP_PORT) Un primer endpoint a l'arrel (http://localhost:HTTP_PORT/) Una resposta per defecte per a la resta de rutes dns del servidor. Resposta HTTP 404 Not found) Executem el servidor Ara, podem afegir un nou punt d'entrada en l'arxiu package.json per a executar el servidor utilitzant npm run . \"scripts\": { \"start\": \"nodemon server.js\", \"test\": \"echo \"Error: no test specified\" && exit 1\" }, Ara podem executar el nostre servidor amb npm run start . Si tot ha anat b\u00e9, en consola ens apareixer\u00e0 Servidor escoltant a l'adre\u00e7a http://localhost:9000 . Ara si podr\u00e0s accedir a l'arrel del servidor trav\u00e9s del navegador al nostre servidor. Obtindr\u00e0s com a resposta un json amb el missatge Ok . ``javascript Resposta: { \"message\": \"Ok\" } Al configurar nodemon server.js com a punt d'entrada, cada vegada que fem canvis al nostre codi, el servidor es llan\u00e7ar\u00e0 de nou amb el nou codi. Connectem a la base de dades SQLite Arribats a este punt, tenim un servidor funcionant, per\u00f2 necessitem que este servidor es connecte a una base de dades per a que l'API consumisca dades des d'ella i envie la resposta al client. En una aplicaci\u00f3 real, normalment aniriem contra un altre servidor connectat per xarxa amb un sistema de gesti\u00f3 de bases de dades tipus MySQL, MariaDB, MongoDB, ... per\u00f2 per simplicitat utilitzarem SQLite. SQLite \u00e9s una implementaci\u00f3 d'una base de dades que funciona contra arxius locals, sense necessitat de tindre tot un sistema que ens gestione la base de dades. Per connectar, utilitzarem la llibreria de javascript sqlite3 . En un nou arxiu database.js crearem un arxiu de connexi\u00f3 i d'inicialitzaci\u00f3 de la base de dades. var sqlite3 = require('sqlite3').verbose() var md5 = require('md5') const DBSOURCE = \"db.sqlite\" let db = new sqlite3.Database(DBSOURCE, (err) => { if (err) { // Cannot open database console.error(err.message) throw err }else{ console.log('Connected to the SQLite database.') db.run(`CREATE TABLE user ( id INTEGER PRIMARY KEY AUTOINCREMENT, name text, email text UNIQUE, password text, CONSTRAINT email_unique UNIQUE (email) )`, (err) => { if (err) { // Table already created }else{ // Table just created, creating some rows var insert = 'INSERT INTO user (name, email, password) VALUES (?,?,?)' db.run(insert, [\"admin\",\"admin@example.com\",\"admin123456\"]) db.run(insert, [\"user\",\"user@example.com\",\"user123456\"]) } }); } }); module.exports = db Fixem-nos en alguns punts importants del codi: Carreguem les llibreries md5 i sqlite3 . Intentem connectar a una base de dades db.sqlite : En cas de no existir, sqlite la crear\u00e0 (en un arxiu). Una vegada creada, intenta crear una taula d'usuaris que contindr\u00e0 els noms, correus i contrasenya. Si la taula no existia, insertar\u00e0 alguns usuaris i les seues contrasenyes. Si la taula ja exixtia, no els insertar\u00e0. Exportem la base de dades per poder utilitzar-la en altres scripts de javascript. Afegim l'API REST amb endpoints d'acc\u00e9s a dades Amb la connexi\u00f3 a la base de dades creada, anem a utilitzar-la en el servidor. El primer que haurem de fer \u00e9s importar el codi en l'arxiu server.js . var express = require(\"express\") var app = express() var db = require(\"./database.js\") Per a una API REST, l'objectiu principal \u00e9s crear una font de dades sense estat, uniforme, sota demanda i basada en URI, que represente entitats en un format est\u00e0ndard (en aquest cas, una resposta JSON). Les principals operacions/punts finals que podeu implementar en un servei REST s\u00f3n: Operaci\u00f3 M\u00e8tode HTTP Endpoint Obtindre llista d'usuaris GET /api/users/ Obtindre un usuari per id GET /api/user/{id} Crear un usuari POST /api/user/ Actualitzar un usuari donat el seu id PATCH /api/user/{id} Eliminar un usuari per id DELETE /api/user/{id} Obtindre llista d'usuaris El primer endpoint de l'API ser\u00e0 obtindre la llista d'usuaris. El seg\u00fcent codi de server.js crear\u00e0 un endpoint per a obtindre una llista d'usuaris. Tingues en compte que has de posar el codi abans del fragment de resposta per defecte en cas d'accedir a un endpoint inexistent. app.get(\"/api/users\", (req, res, next) => { var sql = \"select * from user\" db.all(sql, (err, rows) => { if (err) { res.status(400).json({\"error\":err.message}); return; } res.json({ \"message\":\"success\", \"data\":rows }) }); }); Cada endpoint d' Express.js rep un objecte req (request) que cont\u00e9 les cap\u00e7aleres, els par\u00e0metres i el cos de la petici\u00f3, i un objecte res que contindr\u00e0 el contingut de la resposta i cap\u00e7aleres adicionals. db.all(sql, params, callback) \u00e9s un comandament contra SQLite per obtindre tots els registres d'una petici\u00f3 SQL. La funci\u00f3 de callback , rep un objecte d'error err i row , les files rebudes de la base de dades. Si hi ha algun problema amb la petici\u00f3 SQL, l'error ser\u00e0 un objecte no nul i la funci\u00f3 de callback tornar\u00e0 un HTTP 400 (Petici\u00f3 incorrect) i un JSON amb el missatge d'error. Si tot va com cal, tornar\u00e0 un JSON amb el missatge i les dades (un array de registres/files). Obtindre un usuari per id app.get(\"/api/user/:id\", (req, res, next) => { var sql = \"select * from user where id = \" + req.params.id db.get(sql, (err, row) => { if (err) { res.status(400).json({\"error\":err.message}); }else{ res.json({ \"message\":\"success\", \"data\":row }) } }); }); En este cas, en compte d'obtindre tota la llista d'usuaris, en la petici\u00f3 s'enviar\u00e0 l'id de l'usuari que es vol obtindre i en la resposta obtindrem solament una fila/registre de la base de dades. Utilitzarem per fer-ho un endpoint especial d'Express amb una variable (:id) , mapejada a la variable corresponent de la petici\u00f3 req.params.id . Per exemple, una petici\u00f3 /api/user/1 filtrar\u00e0 la petici\u00f3 utilitzant id = 1. Utilitzant la funci\u00f3 db.get en compte de db.all obtenim una sola fila i no una llista. En este moment podeu realitzar el primer dels exercicis. Crear un usuari En este cas, el m\u00e8tode HTTP utilitzat ser\u00e0 POST per a enviar les dades en les cap\u00e7aleres i no a trav\u00e9s de la URL. Normalment estes dades s'envien codificades en forma de URL des d'un formulari. Necessitem aleshores fer un processat de la petici\u00f3 POST per obtindre les dades que envia el client. Ho fem insertant el seg\u00fcent fragment de codi al server.js : Abans de agregar el seg\u00fcent fragment de codi, necessitem instal\u00b7lar el m\u00f2dul body-parser . npm install body-parser var bodyParser = require(\"body-parser\"); app.use(bodyParser.urlencoded({ extended: false })); app.use(bodyParser.json()); El middleware body-parser intenta obtindre les dades de la petici\u00f3. Per aix\u00f2 analitza el contingut del body que es solen enviar com a URL encoded, com en este cas, o com a JSON i les guarda en un objecte req.body . A l'endpoint seg\u00fcent utilitzem este objecte: app.post(\"/api/user/\", (req, res, next) => { var errors=[] if (!req.body.password){ errors.push(\"No password specified\"); } if (!req.body.email){ errors.push(\"No email specified\"); } if (errors.length){ res.status(400).json({\"error\":errors.join(\",\")}); return; } var data = { name: req.body.name, email: req.body.email, password : req.body.password } var sql ='INSERT INTO user (name, email, password) VALUES (?,?,?)' var params =[data.name, data.email, data.password] db.run(sql, params, function (err, result) { if (err){ res.status(400).json({\"error\": err.message}) return; } res.json({ \"message\": \"success\", \"data\": data, \"id\" : this.lastID }) }); }) Utilitzem app.post() per a restringir el m\u00e8tode sols a POST. El req.body contindr\u00e0 les dades del formulari que envia el client. Les dades en cru tindrien un aspecte com el seg\u00fcent: name=test&email=test%40example.com&password=test123 El body-parser convertir\u00e0 l'anterior cadena en un objecte JSON. {name:'test', email: 'test@example.com', password: 'test123'} Comprovem els camps obligatoris. Si en la petici\u00f3 estan en blanc, tornarem un HTTP 400 (Bad Request) amb la llista d'errors. Utilitzem db.run(sql, params, callback) amb una instrucci\u00f3 INSERT a l'sql, i els valors a guardar. La funci\u00f3 de callback comprovar\u00e0 si hi ha algun error (err != null) . Si tot va com cal, retornem un JSON amb un missatge com a que ha anat b\u00e9, les dades insertades i l'id del nou usuari. Este id \u00e9s \u00fatil en el client si es vol recuperar l'usuari despr\u00e9s de la seua creaci\u00f3. Fixeu-se que ac\u00ed no utilitzem la notaci\u00f3 de funci\u00f3 fletxa com fins ara, per a poder fer \u00fas de l'objecte this i poder recuperar el lastID . En este moment podeu realitzar el segon, tercer i quart exercicis. Actualitzar un usuari donat el seu id Per a operacions d'actualitzaci\u00f3, utilitzem el m\u00e8tode patch d' Express.js , que s'utilitza per a reempla\u00e7ar dades. Enviem des del client un subconjunt de dades a ser reempla\u00e7ades. L'endpoint quedaria aix\u00ed: app.patch(\"/api/user/:id\", (req, res, next) => { var data = { name: req.body.name, email: req.body.email, password : req.body.password ? md5(req.body.password) : null } db.run( `UPDATE user set name = COALESCE(?,name), email = COALESCE(?,email), password = COALESCE(?,password) WHERE id = ?`, [data.name, data.email, data.password, req.params.id], function (err, result) { if (err){ res.status(400).json({\"error\": res.message}) return; } res.json({ message: \"success\", data: data, changes: this.changes }) }); }) Ja que algun dels camps poden estar buits perqu\u00e8 no es volen actualitzarm utilitzem la funci\u00f3 COALESCE per a obtindre el primer valor no nul, de forma que actualitzem en cas de ser null i deixem el camp amb el valor que ja tenia en cas d'enviar-lo a null des del client. De nou utilitzem la notaci\u00f3 cl\u00e0ssica de funcions de callback per a accedir a this.changes , que ens torna el nombre de files actualitzat. Este n\u00famero es podria utilitzar per a comprovar si s'han actualitzat dades o no, per a actualitzar la interf\u00edcie de l'usuari per exemple. En este moment pots fer l'exercici 5 Eliminar un usuari per id La implementaci\u00f3 d'este endpoint es deixa com a exercici 6 En l'exercici 9 comprovar\u00e0s si es vulnerable a SQLi Exercicis L'endpoint de consulta d'usuari per id \u00e9s vulnerable a atacs d'injecci\u00f3 d'SQL? Demostra la teua afirmaci\u00f3. Utilitza Postman per a insertar un usuari. Utilitza curl per a insertar un usuari. Veus alguna configuraci\u00f3 d\u00e8bil en l'endpoint de creaci\u00f3 d'usuari? Si \u00e9s el cas, corregix-la. Prova l'API d'actualitzaci\u00f3 d'usuaris utilitzant postman. Canvia noms, correus i contrasenyes. Prova l'API d'actualitzaci\u00f3 d'usuaris utilitzant curl. Canvia noms, correus i contrasenyes. Construix l'endpoint d'eliminaci\u00f3 d'uausris. Utilitza el m\u00e8tode delete d'Express. Fes proves amb postman i amb curl. L'endpoint d'eliminaci\u00f3 d'usuaris que has implementat \u00e9s vulnerable a atacs d'injecci\u00f3 d'SQL? Comprova-ho. Exercicis d'ampliaci\u00f3 Fes un formulari per a insertar usuaris contra l'endpoint d'inserci\u00f3 d'usuaris. Funciona? En cas negatiu, sabries qu\u00e9 canviar per a fer-lo funcionar?","title":"API Rest"},{"location":"Unitats/Unitat%203/APIRest/#construim-una-api-rest-amb-nodejs-sqlite-i-express-js","text":"En esta pr\u00e0ctica construirem una API Rest utilitzant Node.js, SQLite i Express.js. Els principals components de la nostra API seran: El projecte Node.js creat amb NPM Un servidor web creat amb Express.js per a gestionar els endpoints, les peticiions i les respostes Una base de dades SQLite per a guardar la informaci\u00f3 del backend Les aplicacions reals no utilitzen normalment SQLite, per\u00f2 ho fem aix\u00ed ja que d'esta forma ens estalviem tindre que configurar un sistema gestor de base de dades com puga ser MySQL.","title":"Construim una API Rest amb Node.js, SQLite i Express JS"},{"location":"Unitats/Unitat%203/APIRest/#requisits-previs","text":"Abans de comen\u00e7ar necessitem instal\u00b7lar Node.js i git per a crear un repositori local.","title":"Requisits previs"},{"location":"Unitats/Unitat%203/APIRest/#projecte-nodejs","text":"Per comen\u00e7ar amb el nostre projecte, crearem una carpeta i iniciarem un projecte amb npm: mkdir APIRest-node-express-SQLite cd APIRest-node-express-SQLite npm init NPM ens demanar\u00e0 informaci\u00f3 sobre el nostre projecte. Els camps m\u00e9s importants s\u00f3n el package name i l' entry point . En el nostre cas, el punt d'entrada d'execuci\u00f3 del projecte ser\u00e0 un arxiu anomenat server.js (el nostre servidor Express.js). { \"name\": \"apirest-node-express-sqlite\", \"version\": \"1.0.0\", \"description\": \"APIRest amb nodejs, express i sqlite.\", \"main\": \"server.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"Ferran Cunyat Pellicer\", \"license\": \"GPL-3.0-or-later\" } Amb npm instal\u00b7lem algunes depend\u00e8ncies que necessitem: npm install express sqlite3 md5 npm install --save-dev nodemon Si observes l'arxiu package.json veur\u00e0s que se'ns han afegit estes depend\u00e8ncies. Creeu un repositori de github tamb\u00e9 per guardar el vostre codi. Recordeu afegir node_modules al vostre .gitignore . echo node_modules > .gitignore git init -b main git add . git commit -m \"Primer commit\" git remote add origin <URL_REMOTA> git remote -v git push origin main","title":"Projecte Node.js"},{"location":"Unitats/Unitat%203/APIRest/#el-servidor-expressjs","text":"Ara podem crear el nostre script principal server.js que servir\u00e0 de punt d'entrada al servidor utilitzant express.js. Expresss.js ens permet en poques l\u00ednies tindre un servidor web funcionant: // Create express app var express = require(\"express\") var app = express() // Server port var HTTP_PORT = 9000 // Start server app.listen(HTTP_PORT, () => { console.log(\"Servidor escoltant a l'adre\u00e7a http://localhost:%PORT%\".replace(\"%PORT%\",HTTP_PORT)) }); // Root endpoint app.get(\"/\", (req, res, next) => { res.json({\"message\":\"Ok\"}) }); // Insert here other API endpoints // Default response for any other request // Default response for any other request app.use(function (req, res) { res.status(404).json({ \"error\": \"Invalid endpoint\" }); }); En el codi podem identificar alguns punts importants: El servidor express (app) El port sobre el que escolta el servidor (HTTP_PORT) Un primer endpoint a l'arrel (http://localhost:HTTP_PORT/) Una resposta per defecte per a la resta de rutes dns del servidor. Resposta HTTP 404 Not found)","title":"El servidor Express.js"},{"location":"Unitats/Unitat%203/APIRest/#executem-el-servidor","text":"Ara, podem afegir un nou punt d'entrada en l'arxiu package.json per a executar el servidor utilitzant npm run . \"scripts\": { \"start\": \"nodemon server.js\", \"test\": \"echo \"Error: no test specified\" && exit 1\" }, Ara podem executar el nostre servidor amb npm run start . Si tot ha anat b\u00e9, en consola ens apareixer\u00e0 Servidor escoltant a l'adre\u00e7a http://localhost:9000 . Ara si podr\u00e0s accedir a l'arrel del servidor trav\u00e9s del navegador al nostre servidor. Obtindr\u00e0s com a resposta un json amb el missatge Ok . ``javascript Resposta: { \"message\": \"Ok\" } Al configurar nodemon server.js com a punt d'entrada, cada vegada que fem canvis al nostre codi, el servidor es llan\u00e7ar\u00e0 de nou amb el nou codi.","title":"Executem el servidor"},{"location":"Unitats/Unitat%203/APIRest/#connectem-a-la-base-de-dades-sqlite","text":"Arribats a este punt, tenim un servidor funcionant, per\u00f2 necessitem que este servidor es connecte a una base de dades per a que l'API consumisca dades des d'ella i envie la resposta al client. En una aplicaci\u00f3 real, normalment aniriem contra un altre servidor connectat per xarxa amb un sistema de gesti\u00f3 de bases de dades tipus MySQL, MariaDB, MongoDB, ... per\u00f2 per simplicitat utilitzarem SQLite. SQLite \u00e9s una implementaci\u00f3 d'una base de dades que funciona contra arxius locals, sense necessitat de tindre tot un sistema que ens gestione la base de dades. Per connectar, utilitzarem la llibreria de javascript sqlite3 . En un nou arxiu database.js crearem un arxiu de connexi\u00f3 i d'inicialitzaci\u00f3 de la base de dades. var sqlite3 = require('sqlite3').verbose() var md5 = require('md5') const DBSOURCE = \"db.sqlite\" let db = new sqlite3.Database(DBSOURCE, (err) => { if (err) { // Cannot open database console.error(err.message) throw err }else{ console.log('Connected to the SQLite database.') db.run(`CREATE TABLE user ( id INTEGER PRIMARY KEY AUTOINCREMENT, name text, email text UNIQUE, password text, CONSTRAINT email_unique UNIQUE (email) )`, (err) => { if (err) { // Table already created }else{ // Table just created, creating some rows var insert = 'INSERT INTO user (name, email, password) VALUES (?,?,?)' db.run(insert, [\"admin\",\"admin@example.com\",\"admin123456\"]) db.run(insert, [\"user\",\"user@example.com\",\"user123456\"]) } }); } }); module.exports = db Fixem-nos en alguns punts importants del codi: Carreguem les llibreries md5 i sqlite3 . Intentem connectar a una base de dades db.sqlite : En cas de no existir, sqlite la crear\u00e0 (en un arxiu). Una vegada creada, intenta crear una taula d'usuaris que contindr\u00e0 els noms, correus i contrasenya. Si la taula no existia, insertar\u00e0 alguns usuaris i les seues contrasenyes. Si la taula ja exixtia, no els insertar\u00e0. Exportem la base de dades per poder utilitzar-la en altres scripts de javascript.","title":"Connectem a la base de dades SQLite"},{"location":"Unitats/Unitat%203/APIRest/#afegim-lapi-rest-amb-endpoints-dacces-a-dades","text":"Amb la connexi\u00f3 a la base de dades creada, anem a utilitzar-la en el servidor. El primer que haurem de fer \u00e9s importar el codi en l'arxiu server.js . var express = require(\"express\") var app = express() var db = require(\"./database.js\") Per a una API REST, l'objectiu principal \u00e9s crear una font de dades sense estat, uniforme, sota demanda i basada en URI, que represente entitats en un format est\u00e0ndard (en aquest cas, una resposta JSON). Les principals operacions/punts finals que podeu implementar en un servei REST s\u00f3n: Operaci\u00f3 M\u00e8tode HTTP Endpoint Obtindre llista d'usuaris GET /api/users/ Obtindre un usuari per id GET /api/user/{id} Crear un usuari POST /api/user/ Actualitzar un usuari donat el seu id PATCH /api/user/{id} Eliminar un usuari per id DELETE /api/user/{id}","title":"Afegim l'API REST amb endpoints d'acc\u00e9s a dades"},{"location":"Unitats/Unitat%203/APIRest/#obtindre-llista-dusuaris","text":"El primer endpoint de l'API ser\u00e0 obtindre la llista d'usuaris. El seg\u00fcent codi de server.js crear\u00e0 un endpoint per a obtindre una llista d'usuaris. Tingues en compte que has de posar el codi abans del fragment de resposta per defecte en cas d'accedir a un endpoint inexistent. app.get(\"/api/users\", (req, res, next) => { var sql = \"select * from user\" db.all(sql, (err, rows) => { if (err) { res.status(400).json({\"error\":err.message}); return; } res.json({ \"message\":\"success\", \"data\":rows }) }); }); Cada endpoint d' Express.js rep un objecte req (request) que cont\u00e9 les cap\u00e7aleres, els par\u00e0metres i el cos de la petici\u00f3, i un objecte res que contindr\u00e0 el contingut de la resposta i cap\u00e7aleres adicionals. db.all(sql, params, callback) \u00e9s un comandament contra SQLite per obtindre tots els registres d'una petici\u00f3 SQL. La funci\u00f3 de callback , rep un objecte d'error err i row , les files rebudes de la base de dades. Si hi ha algun problema amb la petici\u00f3 SQL, l'error ser\u00e0 un objecte no nul i la funci\u00f3 de callback tornar\u00e0 un HTTP 400 (Petici\u00f3 incorrect) i un JSON amb el missatge d'error. Si tot va com cal, tornar\u00e0 un JSON amb el missatge i les dades (un array de registres/files).","title":"Obtindre llista d'usuaris"},{"location":"Unitats/Unitat%203/APIRest/#obtindre-un-usuari-per-id","text":"app.get(\"/api/user/:id\", (req, res, next) => { var sql = \"select * from user where id = \" + req.params.id db.get(sql, (err, row) => { if (err) { res.status(400).json({\"error\":err.message}); }else{ res.json({ \"message\":\"success\", \"data\":row }) } }); }); En este cas, en compte d'obtindre tota la llista d'usuaris, en la petici\u00f3 s'enviar\u00e0 l'id de l'usuari que es vol obtindre i en la resposta obtindrem solament una fila/registre de la base de dades. Utilitzarem per fer-ho un endpoint especial d'Express amb una variable (:id) , mapejada a la variable corresponent de la petici\u00f3 req.params.id . Per exemple, una petici\u00f3 /api/user/1 filtrar\u00e0 la petici\u00f3 utilitzant id = 1. Utilitzant la funci\u00f3 db.get en compte de db.all obtenim una sola fila i no una llista. En este moment podeu realitzar el primer dels exercicis.","title":"Obtindre un usuari per id"},{"location":"Unitats/Unitat%203/APIRest/#crear-un-usuari","text":"En este cas, el m\u00e8tode HTTP utilitzat ser\u00e0 POST per a enviar les dades en les cap\u00e7aleres i no a trav\u00e9s de la URL. Normalment estes dades s'envien codificades en forma de URL des d'un formulari. Necessitem aleshores fer un processat de la petici\u00f3 POST per obtindre les dades que envia el client. Ho fem insertant el seg\u00fcent fragment de codi al server.js : Abans de agregar el seg\u00fcent fragment de codi, necessitem instal\u00b7lar el m\u00f2dul body-parser . npm install body-parser var bodyParser = require(\"body-parser\"); app.use(bodyParser.urlencoded({ extended: false })); app.use(bodyParser.json()); El middleware body-parser intenta obtindre les dades de la petici\u00f3. Per aix\u00f2 analitza el contingut del body que es solen enviar com a URL encoded, com en este cas, o com a JSON i les guarda en un objecte req.body . A l'endpoint seg\u00fcent utilitzem este objecte: app.post(\"/api/user/\", (req, res, next) => { var errors=[] if (!req.body.password){ errors.push(\"No password specified\"); } if (!req.body.email){ errors.push(\"No email specified\"); } if (errors.length){ res.status(400).json({\"error\":errors.join(\",\")}); return; } var data = { name: req.body.name, email: req.body.email, password : req.body.password } var sql ='INSERT INTO user (name, email, password) VALUES (?,?,?)' var params =[data.name, data.email, data.password] db.run(sql, params, function (err, result) { if (err){ res.status(400).json({\"error\": err.message}) return; } res.json({ \"message\": \"success\", \"data\": data, \"id\" : this.lastID }) }); }) Utilitzem app.post() per a restringir el m\u00e8tode sols a POST. El req.body contindr\u00e0 les dades del formulari que envia el client. Les dades en cru tindrien un aspecte com el seg\u00fcent: name=test&email=test%40example.com&password=test123 El body-parser convertir\u00e0 l'anterior cadena en un objecte JSON. {name:'test', email: 'test@example.com', password: 'test123'} Comprovem els camps obligatoris. Si en la petici\u00f3 estan en blanc, tornarem un HTTP 400 (Bad Request) amb la llista d'errors. Utilitzem db.run(sql, params, callback) amb una instrucci\u00f3 INSERT a l'sql, i els valors a guardar. La funci\u00f3 de callback comprovar\u00e0 si hi ha algun error (err != null) . Si tot va com cal, retornem un JSON amb un missatge com a que ha anat b\u00e9, les dades insertades i l'id del nou usuari. Este id \u00e9s \u00fatil en el client si es vol recuperar l'usuari despr\u00e9s de la seua creaci\u00f3. Fixeu-se que ac\u00ed no utilitzem la notaci\u00f3 de funci\u00f3 fletxa com fins ara, per a poder fer \u00fas de l'objecte this i poder recuperar el lastID . En este moment podeu realitzar el segon, tercer i quart exercicis.","title":"Crear un usuari"},{"location":"Unitats/Unitat%203/APIRest/#actualitzar-un-usuari-donat-el-seu-id","text":"Per a operacions d'actualitzaci\u00f3, utilitzem el m\u00e8tode patch d' Express.js , que s'utilitza per a reempla\u00e7ar dades. Enviem des del client un subconjunt de dades a ser reempla\u00e7ades. L'endpoint quedaria aix\u00ed: app.patch(\"/api/user/:id\", (req, res, next) => { var data = { name: req.body.name, email: req.body.email, password : req.body.password ? md5(req.body.password) : null } db.run( `UPDATE user set name = COALESCE(?,name), email = COALESCE(?,email), password = COALESCE(?,password) WHERE id = ?`, [data.name, data.email, data.password, req.params.id], function (err, result) { if (err){ res.status(400).json({\"error\": res.message}) return; } res.json({ message: \"success\", data: data, changes: this.changes }) }); }) Ja que algun dels camps poden estar buits perqu\u00e8 no es volen actualitzarm utilitzem la funci\u00f3 COALESCE per a obtindre el primer valor no nul, de forma que actualitzem en cas de ser null i deixem el camp amb el valor que ja tenia en cas d'enviar-lo a null des del client. De nou utilitzem la notaci\u00f3 cl\u00e0ssica de funcions de callback per a accedir a this.changes , que ens torna el nombre de files actualitzat. Este n\u00famero es podria utilitzar per a comprovar si s'han actualitzat dades o no, per a actualitzar la interf\u00edcie de l'usuari per exemple. En este moment pots fer l'exercici 5","title":"Actualitzar un usuari donat el seu id"},{"location":"Unitats/Unitat%203/APIRest/#eliminar-un-usuari-per-id","text":"La implementaci\u00f3 d'este endpoint es deixa com a exercici 6 En l'exercici 9 comprovar\u00e0s si es vulnerable a SQLi","title":"Eliminar un usuari per id"},{"location":"Unitats/Unitat%203/APIRest/#exercicis","text":"L'endpoint de consulta d'usuari per id \u00e9s vulnerable a atacs d'injecci\u00f3 d'SQL? Demostra la teua afirmaci\u00f3. Utilitza Postman per a insertar un usuari. Utilitza curl per a insertar un usuari. Veus alguna configuraci\u00f3 d\u00e8bil en l'endpoint de creaci\u00f3 d'usuari? Si \u00e9s el cas, corregix-la. Prova l'API d'actualitzaci\u00f3 d'usuaris utilitzant postman. Canvia noms, correus i contrasenyes. Prova l'API d'actualitzaci\u00f3 d'usuaris utilitzant curl. Canvia noms, correus i contrasenyes. Construix l'endpoint d'eliminaci\u00f3 d'uausris. Utilitza el m\u00e8tode delete d'Express. Fes proves amb postman i amb curl. L'endpoint d'eliminaci\u00f3 d'usuaris que has implementat \u00e9s vulnerable a atacs d'injecci\u00f3 d'SQL? Comprova-ho.","title":"Exercicis"},{"location":"Unitats/Unitat%203/APIRest/#exercicis-dampliacio","text":"Fes un formulari per a insertar usuaris contra l'endpoint d'inserci\u00f3 d'usuaris. Funciona? En cas negatiu, sabries qu\u00e9 canviar per a fer-lo funcionar?","title":"Exercicis d'ampliaci\u00f3"},{"location":"Unitats/Unitat%203/respostes%20exercicis/respostes/","text":"L'endpoint de consulta d'usuari per id \u00e9s vulnerable a atacs d'injecci\u00f3 d'SQL? Demostra la teua afirmaci\u00f3. \u00c9s vulnerable. Amb el payload: 1%20UNION%20SELECT%20 %20FROM%20user%20WHERE%20ID%20=%203%20order%20by%20id%20desc obtenim qualsevol,usuari de qualsevol id. http://localhost:9000/api/user/1%20UNION%20SELECT%20 %20FROM%20user%20WHERE%20ID%20=%203%20order%20by%20id%20desc Obtenim l'usuari amb id = 3 Per mitigar esta vulnerabilitat utilitzem la parametritzaci\u00f3 (SQL parameter binding): Mirar /api/user2/ Utilitza Postman per a insertar un usuari. Postman Utilitza curl per a insertar un usuari. curl -d \"name=test&email=test%40example.com&password=test123\" -X POST http://localhost:9000/api/user/ Veus alguna configuraci\u00f3 d\u00e8bil en l'endpoint de creaci\u00f3 d'usuari? Si \u00e9s el cas, corregix-la. // Afegim el m\u00f2dul md5 var md5 = require(\"md5\") // Encriptem la contrasenya abans d'insertar-la password : md5(req.body.password) Prova l'API d'actualitzaci\u00f3 d'usuaris utilitzant postman. Canvia noms, correus i contrasenyes. Prova l'API d'actualitzaci\u00f3 d'usuaris utilitzant curl. Canvia noms, correus i contrasenyes. curl -X PATCH -d \"email=user@example1.com\" http://localhost:9000/api/user/2 Construix l'endpoint d'eliminaci\u00f3 d'usuaris. Utilitza el m\u00e8tode delete d'Express. app.delete(\"/api/user/:id\", (req, res, next) => { db.run( 'DELETE FROM user WHERE id = ?', req.params.id, function (err, result) { if (err){ res.status(400).json({\"error\": res.message}) return; } res.json({\"message\":\"deleted\", changes: this.changes}) }); }) Fes proves amb postman i amb curl. curl -X \"DELETE\" http://localhost:8000/api/user/2 L'endpoint d'eliminaci\u00f3 d'usuaris que has implementat \u00e9s vulnerable a atacs d'injecci\u00f3 d'SQL? Comprova-ho.","title":"Respostes"}]}