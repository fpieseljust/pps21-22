{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Benvinguts a la Web de PPS Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna","title":"Home"},{"location":"#benvinguts-a-la-web-de-pps","text":"Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna","title":"Benvinguts a la Web de PPS"},{"location":"about/","text":"Sobre la web de PPS Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna Autor: Ferran Cunyat Pellicer - Departament d'Inform\u00e0tica","title":"About"},{"location":"about/#sobre-la-web-de-pps","text":"Curs Especialitzaci\u00f3 en Ciberseguretat - Curs 21 - 22 IES Jaume II \"El Just\" - Tavernes de la valldigna Autor: Ferran Cunyat Pellicer - Departament d'Inform\u00e0tica","title":"Sobre la web de PPS"},{"location":"Unitats/Unitat%201/TDD/","text":"Basat en el material publicat a https://aulasoftwarelibre.github.io/taller-de-python/Testing/TDD/ baix llic\u00e8ncia Copyleft - CC BY-NC 4.0 - Aula de Software Libre Test Driven Developement El desenvolupament guiat per proves de programari, o Test-driven development (TDD) \u00e9s una pr\u00e0ctica d'enginyeria de programari que involucra dues pr\u00e0ctiques m\u00e9s: Escriure les proves primer (Test First Development) i Refactoritzaci\u00f3 (Refactoring). Per escriure les proves generalment es fan servir les proves unit\u00e0ries (unit test en angl\u00e8s). En primer lloc, s'escriu una prova i es verifica que la nova prova falla. A continuaci\u00f3, s'implementa el codi que fa que la prova passe satisfact\u00f2riament i tot seguit es refactoritza el codi escrit. El prop\u00f2sit del desenvolupament guiat per proves \u00e9s aconseguir un codi net que funcione. La idea \u00e9s que els requisits siguen tradu\u00efts a proves, aix\u00ed, quan les proves passen es garantir\u00e0 que el programari compleix amb els requisits que s'han establert. Com podem implementar-lo en Python? Si b\u00e9 la biblioteca est\u00e0ndard de Python ve amb unittest com a llibreria est\u00e0ndar per a proves, Pytest \u00e9s el framework de refer\u00e8ncia per provar el codi Python. Pytest fa que siga f\u00e0cil escriure, organitzar i executar proves. En comparaci\u00f3 amb unittest, de la biblioteca est\u00e0ndard de Python, Pytest: Requereix menys codi repetitiu perqu\u00e8 els seus conjunts de proves siguen m\u00e9s llegibles. Suports de la plana assertdeclaraci\u00f3 , que \u00e9s molt m\u00e9s f\u00e0cil de llegir i m\u00e9s f\u00e0cil de recordar en comparaci\u00f3 amb els assertSomethingm\u00e8todes - com assertEquals , assertTruey assertContains - en unittest. S'actualitza m\u00e9s sovint, ja que no forma part de la biblioteca est\u00e0ndard de Python. Simplifica la configuraci\u00f3 i el desmuntatge de l'estat de prova amb el sistema de fixaci\u00f3. Utilitza un enfocament funcional. A m\u00e9s, amb Pytest podem tindre un estil coherent a tots els nostres projectes de Python. Per exemple, suposem que teniu dues aplicacions web: una constru\u00efda amb Django i l'altra constru\u00efda amb Flask. Sense Pytest, el m\u00e9s probable \u00e9s que aprofitem el framework de Django juntament amb una extensi\u00f3 de Flask com Flask-Testing. Per tant, els seus conjunts de proves tindrien estils diferents. Amb Pytest, d'altra banda, tots dos conjunts de proves tindrien un estil de codi coherent, cosa que facilitaria el salt de l'un a l'altre. Pytest tamb\u00e9 t\u00e9 un gran ecosistema de complements mantingut per la comunitat. Com per exemple: Pytest-django : proporciona un conjunt de ferramentes creades espec\u00edficament per a provar aplicacions de Django Pytest-xdist : s'utilitza per a executar proves en paral\u00b7lel Pytest-cov : agrega soport de cobertura de codi Pytest-instafail : mostra fallos i errors inmediatament en lloc d'esperar fins el final d'una execuci\u00f3 Pytest El primer que hem de fer si volem utilitzar Pytest per testejar el nostre codi \u00e9s instal\u00b7lar-lo. Per aix\u00f2 obrirem una nova terminal i introduirem la seg\u00fcent ordre (fes-ho a un entorn virtual). Tal com es pot veure estem fent \u00fas de pip el gestor de paquets de Python que pr\u00e8viament hav\u00edem instal\u00b7lat. pip install pytest Una vegada fet aix\u00f2 podem comprovar la versi\u00f3 que tenim instal\u00b7lada escrivint la seg\u00fcent ordre: pytest --version I obtindr\u00edem un resultat com aquest: This is pytest version 4.6.9, imported from /usr/lib/python2.7/dist-packages/pytest.pyc Una vegada ho hem instal\u00b7lat i hem comprovat la versi\u00f3 que tenim arriba l'hora de comen\u00e7ar a fer els nostres primers tests. A l'hora d'escriure les proves cal que tant els fitxers on les escriurem com les mateixes funcions de prova dins del fitxer comencen amb el prefix test_ , ja que si no, quan cridem a pytest passant-li la ruta del directori, aquest no les trobar\u00e0. Un exemple de crida a Pytest seria una cosa aix\u00ed: pytest /home/ferran/Desktop/Curs Sintaxis El funcionament de pytest \u00e9s similar al de totes les llibreries de testing . assert Val1 == Val2 #\u00bfVal1 igual Val2? assert Val1 != Val2 #\u00bfVal1 diferente Val2? assert Val1 < Val2 #\u00bfVal1 menor que Val2? assert Val1 <= Val2 #\u00bfVal1 menor o igual que Val2? assert Val1 > Val2 #\u00bfVal1 mayor que Val2? assert Val1 >= Val2 #\u00bfVal1 mayor o igual que Val2? assert Val1 == TRUE #\u00bfVal1 igual TRUE? assert Val1 == FALSE #\u00bfVal1 igual FALSE? Exemple Suposem que hem d'implementar una calculadora. Per a aix\u00f2, definirem una s\u00e8rie de funcions que volem que estiguen disponibles a la nostra calculadora. Agafarem la funci\u00f3 suma per a continuar amb l'exemple. Si seguim al peu de la lletra les indicacions de TDD, el primer que hem de fer \u00e9s crear la funci\u00f3 buida simplement per poder cridar-la, implementar la seva prova i executar-la comprovant la falla. Per a aix\u00f2 hem de crear un nou fitxer a qui anomenem operations.py en el que definirem les funcions i crearem un fitxer anomenat test_.py on crearem la nostra funci\u00f3 test_operations () Primers passos operations.py def suma(sumad1, sumand2): return 0 test_.py import pytest import operations def test_operations(): assert operations.suma(3,3) == 6 Una vegada hem fet aix\u00f2, procedim a la refactoritzaci\u00f3 . Hem d'implementar la nostra funci\u00f3 encarregada de calcular la suma: operations.py def suma(sumand1, sumand2): return sumand1 + sumand2 Una vegada implementada, hem d'executar les proves sobre la funci\u00f3 suma: pytest test_.py I si tot ha anat b\u00e9, obtindrem un resultat similar a aquest: ===================================== comen\u00e7a la sessi\u00f3 de prova ========== ============================ plataforma linux -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/ferran/Desktop/Curs collected 1 item test_.py . [100%] ====================================== 1 passat en 0,01 s ======= ================================= Exercici Acaba d'implementar les funcions resta, multiplicaci\u00f3, divisi\u00f3, arrel, exponent i factorial i el\u00b7labora els seus testos corresponents.","title":"TDD"},{"location":"Unitats/Unitat%201/TDD/#test-driven-developement","text":"El desenvolupament guiat per proves de programari, o Test-driven development (TDD) \u00e9s una pr\u00e0ctica d'enginyeria de programari que involucra dues pr\u00e0ctiques m\u00e9s: Escriure les proves primer (Test First Development) i Refactoritzaci\u00f3 (Refactoring). Per escriure les proves generalment es fan servir les proves unit\u00e0ries (unit test en angl\u00e8s). En primer lloc, s'escriu una prova i es verifica que la nova prova falla. A continuaci\u00f3, s'implementa el codi que fa que la prova passe satisfact\u00f2riament i tot seguit es refactoritza el codi escrit. El prop\u00f2sit del desenvolupament guiat per proves \u00e9s aconseguir un codi net que funcione. La idea \u00e9s que els requisits siguen tradu\u00efts a proves, aix\u00ed, quan les proves passen es garantir\u00e0 que el programari compleix amb els requisits que s'han establert.","title":"Test Driven Developement"},{"location":"Unitats/Unitat%201/TDD/#com-podem-implementar-lo-en-python","text":"Si b\u00e9 la biblioteca est\u00e0ndard de Python ve amb unittest com a llibreria est\u00e0ndar per a proves, Pytest \u00e9s el framework de refer\u00e8ncia per provar el codi Python. Pytest fa que siga f\u00e0cil escriure, organitzar i executar proves. En comparaci\u00f3 amb unittest, de la biblioteca est\u00e0ndard de Python, Pytest: Requereix menys codi repetitiu perqu\u00e8 els seus conjunts de proves siguen m\u00e9s llegibles. Suports de la plana assertdeclaraci\u00f3 , que \u00e9s molt m\u00e9s f\u00e0cil de llegir i m\u00e9s f\u00e0cil de recordar en comparaci\u00f3 amb els assertSomethingm\u00e8todes - com assertEquals , assertTruey assertContains - en unittest. S'actualitza m\u00e9s sovint, ja que no forma part de la biblioteca est\u00e0ndard de Python. Simplifica la configuraci\u00f3 i el desmuntatge de l'estat de prova amb el sistema de fixaci\u00f3. Utilitza un enfocament funcional. A m\u00e9s, amb Pytest podem tindre un estil coherent a tots els nostres projectes de Python. Per exemple, suposem que teniu dues aplicacions web: una constru\u00efda amb Django i l'altra constru\u00efda amb Flask. Sense Pytest, el m\u00e9s probable \u00e9s que aprofitem el framework de Django juntament amb una extensi\u00f3 de Flask com Flask-Testing. Per tant, els seus conjunts de proves tindrien estils diferents. Amb Pytest, d'altra banda, tots dos conjunts de proves tindrien un estil de codi coherent, cosa que facilitaria el salt de l'un a l'altre. Pytest tamb\u00e9 t\u00e9 un gran ecosistema de complements mantingut per la comunitat. Com per exemple: Pytest-django : proporciona un conjunt de ferramentes creades espec\u00edficament per a provar aplicacions de Django Pytest-xdist : s'utilitza per a executar proves en paral\u00b7lel Pytest-cov : agrega soport de cobertura de codi Pytest-instafail : mostra fallos i errors inmediatament en lloc d'esperar fins el final d'una execuci\u00f3","title":"Com podem implementar-lo en Python?"},{"location":"Unitats/Unitat%201/TDD/#pytest","text":"El primer que hem de fer si volem utilitzar Pytest per testejar el nostre codi \u00e9s instal\u00b7lar-lo. Per aix\u00f2 obrirem una nova terminal i introduirem la seg\u00fcent ordre (fes-ho a un entorn virtual). Tal com es pot veure estem fent \u00fas de pip el gestor de paquets de Python que pr\u00e8viament hav\u00edem instal\u00b7lat. pip install pytest Una vegada fet aix\u00f2 podem comprovar la versi\u00f3 que tenim instal\u00b7lada escrivint la seg\u00fcent ordre: pytest --version I obtindr\u00edem un resultat com aquest: This is pytest version 4.6.9, imported from /usr/lib/python2.7/dist-packages/pytest.pyc Una vegada ho hem instal\u00b7lat i hem comprovat la versi\u00f3 que tenim arriba l'hora de comen\u00e7ar a fer els nostres primers tests. A l'hora d'escriure les proves cal que tant els fitxers on les escriurem com les mateixes funcions de prova dins del fitxer comencen amb el prefix test_ , ja que si no, quan cridem a pytest passant-li la ruta del directori, aquest no les trobar\u00e0. Un exemple de crida a Pytest seria una cosa aix\u00ed: pytest /home/ferran/Desktop/Curs","title":"Pytest"},{"location":"Unitats/Unitat%201/TDD/#sintaxis","text":"El funcionament de pytest \u00e9s similar al de totes les llibreries de testing . assert Val1 == Val2 #\u00bfVal1 igual Val2? assert Val1 != Val2 #\u00bfVal1 diferente Val2? assert Val1 < Val2 #\u00bfVal1 menor que Val2? assert Val1 <= Val2 #\u00bfVal1 menor o igual que Val2? assert Val1 > Val2 #\u00bfVal1 mayor que Val2? assert Val1 >= Val2 #\u00bfVal1 mayor o igual que Val2? assert Val1 == TRUE #\u00bfVal1 igual TRUE? assert Val1 == FALSE #\u00bfVal1 igual FALSE?","title":"Sintaxis"},{"location":"Unitats/Unitat%201/TDD/#exemple","text":"Suposem que hem d'implementar una calculadora. Per a aix\u00f2, definirem una s\u00e8rie de funcions que volem que estiguen disponibles a la nostra calculadora. Agafarem la funci\u00f3 suma per a continuar amb l'exemple. Si seguim al peu de la lletra les indicacions de TDD, el primer que hem de fer \u00e9s crear la funci\u00f3 buida simplement per poder cridar-la, implementar la seva prova i executar-la comprovant la falla. Per a aix\u00f2 hem de crear un nou fitxer a qui anomenem operations.py en el que definirem les funcions i crearem un fitxer anomenat test_.py on crearem la nostra funci\u00f3 test_operations ()","title":"Exemple"},{"location":"Unitats/Unitat%201/TDD/#primers-passos","text":"","title":"Primers passos"},{"location":"Unitats/Unitat%201/TDD/#operationspy","text":"def suma(sumad1, sumand2): return 0","title":"operations.py"},{"location":"Unitats/Unitat%201/TDD/#test_py","text":"import pytest import operations def test_operations(): assert operations.suma(3,3) == 6 Una vegada hem fet aix\u00f2, procedim a la refactoritzaci\u00f3 . Hem d'implementar la nostra funci\u00f3 encarregada de calcular la suma:","title":"test_.py"},{"location":"Unitats/Unitat%201/TDD/#operationspy_1","text":"def suma(sumand1, sumand2): return sumand1 + sumand2 Una vegada implementada, hem d'executar les proves sobre la funci\u00f3 suma: pytest test_.py I si tot ha anat b\u00e9, obtindrem un resultat similar a aquest: ===================================== comen\u00e7a la sessi\u00f3 de prova ========== ============================ plataforma linux -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/ferran/Desktop/Curs collected 1 item test_.py . [100%] ====================================== 1 passat en 0,01 s ======= =================================","title":"operations.py"},{"location":"Unitats/Unitat%201/TDD/#exercici","text":"Acaba d'implementar les funcions resta, multiplicaci\u00f3, divisi\u00f3, arrel, exponent i factorial i el\u00b7labora els seus testos corresponents.","title":"Exercici"}]}